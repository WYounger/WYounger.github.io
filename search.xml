<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Test]]></title>
    <url>%2F2019%2F10%2F05%2FTest%2F</url>
    <content type="text"><![CDATA[测试使用]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList.md]]></title>
    <url>%2F2019%2F10%2F05%2Fjdk%2FArrayList%2F</url>
    <content type="text"><![CDATA[变长数组 基于JDK9，有的源码上有英文注释，将不再做过多的注解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319132013211322132313241325132613271328132913301331133213331334133513361337133813391340134113421343134413451346134713481349135013511352135313541355135613571358135913601361136213631364136513661367136813691370137113721373137413751376137713781379138013811382138313841385138613871388138913901391139213931394139513961397139813991400140114021403140414051406140714081409141014111412141314141415141614171418141914201421142214231424142514261427142814291430143114321433143414351436143714381439144014411442144314441445144614471448144914501451145214531454145514561457145814591460146114621463146414651466146714681469147014711472147314741475147614771478147914801481148214831484148514861487148814891490149114921493149414951496149714981499150015011502150315041505150615071508150915101511151215131514151515161517151815191520152115221523152415251526152715281529153015311532153315341535153615371538153915401541154215431544154515461547154815491550155115521553155415551556155715581559156015611562156315641565156615671568156915701571157215731574157515761577157815791580158115821583158415851586158715881589159015911592159315941595159615971598/* * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. * * * * * * * * * * * * * * * * * * * * */package java.util;import java.util.function.Consumer;import java.util.function.Predicate;import java.util.function.UnaryOperator;import jdk.internal.misc.SharedSecrets;/** * Resizable-array implementation of the &#123;@code List&#125; interface. Implements * all optional list operations, and permits all elements, including * &#123;@code null&#125;. In addition to implementing the &#123;@code List&#125; interface, * this class provides methods to manipulate the size of the array that is * used internally to store the list. (This class is roughly equivalent to * &#123;@code Vector&#125;, except that it is unsynchronized.) * * &lt;p&gt;The &#123;@code size&#125;, &#123;@code isEmpty&#125;, &#123;@code get&#125;, &#123;@code set&#125;, * &#123;@code iterator&#125;, and &#123;@code listIterator&#125; operations run in constant * time. The &#123;@code add&#125; operation runs in &lt;i&gt;amortized constant time&lt;/i&gt;, * that is, adding n elements requires O(n) time. All of the other operations * run in linear time (roughly speaking). The constant factor is low compared * to that for the &#123;@code LinkedList&#125; implementation. * * &lt;p&gt;Each &#123;@code ArrayList&#125; instance has a &lt;i&gt;capacity&lt;/i&gt;. The capacity is * the size of the array used to store the elements in the list. It is always * at least as large as the list size. As elements are added to an ArrayList, * its capacity grows automatically. The details of the growth policy are not * specified beyond the fact that adding an element has constant amortized * time cost. * * &lt;p&gt;An application can increase the capacity of an &#123;@code ArrayList&#125; instance * before adding a large number of elements using the &#123;@code ensureCapacity&#125; * operation. This may reduce the amount of incremental reallocation. * * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt; * If multiple threads access an &#123;@code ArrayList&#125; instance concurrently, * and at least one of the threads modifies the list structurally, it * &lt;i&gt;must&lt;/i&gt; be synchronized externally. (A structural modification is * any operation that adds or deletes one or more elements, or explicitly * resizes the backing array; merely setting the value of an element is not * a structural modification.) This is typically accomplished by * synchronizing on some object that naturally encapsulates the list. * * If no such object exists, the list should be "wrapped" using the * &#123;@link Collections#synchronizedList Collections.synchronizedList&#125; * method. This is best done at creation time, to prevent accidental * unsynchronized access to the list:&lt;pre&gt; * List list = Collections.synchronizedList(new ArrayList(...));&lt;/pre&gt; * * &lt;p id="fail-fast"&gt; * The iterators returned by this class's &#123;@link #iterator() iterator&#125; and * &#123;@link #listIterator(int) listIterator&#125; methods are &lt;em&gt;fail-fast&lt;/em&gt;: * if the list is structurally modified at any time after the iterator is * created, in any way except through the iterator's own * &#123;@link ListIterator#remove() remove&#125; or * &#123;@link ListIterator#add(Object) add&#125; methods, the iterator will throw a * &#123;@link ConcurrentModificationException&#125;. Thus, in the face of * concurrent modification, the iterator fails quickly and cleanly, rather * than risking arbitrary, non-deterministic behavior at an undetermined * time in the future. * * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed * as it is, generally speaking, impossible to make any hard guarantees in the * presence of unsynchronized concurrent modification. Fail-fast iterators * throw &#123;@code ConcurrentModificationException&#125; on a best-effort basis. * Therefore, it would be wrong to write a program that depended on this * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators * should be used only to detect bugs.&lt;/i&gt; * * &lt;p&gt;This class is a member of the * &lt;a href="&#123;@docRoot&#125;/java/util/package-summary.html#CollectionsFramework"&gt; * Java Collections Framework&lt;/a&gt;. * * @param &lt;E&gt; the type of elements in this list * * @author Josh Bloch * @author Neal Gafter * @see Collection * @see List * @see LinkedList * @see Vector * @since 1.2 */public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; /** * Default initial capacity. */ private static final int DEFAULT_CAPACITY = 10; /** * Shared empty array instance used for empty instances. */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */ //注意使用Object数组来存储元素 transient Object[] elementData; // non-private to simplify nested class access /** * The size of the ArrayList (the number of elements it contains). * * @serial */ private int size; /** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125; /** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // defend against c.toArray (incorrectly) not returning Object[] // (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; /** * Trims the capacity of this &#123;@code ArrayList&#125; instance to be the * list's current size. An application can use this operation to minimize * the storage of an &#123;@code ArrayList&#125; instance. */ public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125; /** * Increases the capacity of this &#123;@code ArrayList&#125; instance, if * necessary, to ensure that it can hold at least the number of elements * specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ public void ensureCapacity(int minCapacity) &#123; if (minCapacity &gt; elementData.length &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) &#123; modCount++; grow(minCapacity); &#125; &#125; /** * The maximum size of array to allocate (unless necessary). * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity * @throws OutOfMemoryError if minCapacity is less than zero */ private Object[] grow(int minCapacity) &#123; return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity)); &#125; private Object[] grow() &#123; return grow(size + 1); &#125; /** * Returns a capacity at least as large as the given minimum capacity. * Returns the current capacity increased by 50% if that suffices. * Will not return a capacity greater than MAX_ARRAY_SIZE unless * the given minimum capacity is greater than MAX_ARRAY_SIZE. * * @param minCapacity the desired minimum capacity * @throws OutOfMemoryError if minCapacity is less than zero */ private int newCapacity(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt;= 0) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) return Math.max(DEFAULT_CAPACITY, minCapacity); if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return minCapacity; &#125; return (newCapacity - MAX_ARRAY_SIZE &lt;= 0) ? newCapacity : hugeCapacity(minCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; /** * Returns the number of elements in this list. * * @return the number of elements in this list */ public int size() &#123; return size; &#125; /** * Returns &#123;@code true&#125; if this list contains no elements. * * @return &#123;@code true&#125; if this list contains no elements */ public boolean isEmpty() &#123; return size == 0; &#125; /** * Returns &#123;@code true&#125; if this list contains the specified element. * More formally, returns &#123;@code true&#125; if and only if this list contains * at least one element &#123;@code e&#125; such that * &#123;@code Objects.equals(o, e)&#125;. * * @param o element whose presence in this list is to be tested * @return &#123;@code true&#125; if this list contains the specified element */ public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125; /** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &#123;@code i&#125; such that * &#123;@code Objects.equals(o, get(i))&#125;, * or -1 if there is no such index. */ public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * Returns the index of the last occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the highest index &#123;@code i&#125; such that * &#123;@code Objects.equals(o, get(i))&#125;, * or -1 if there is no such index. */ public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * Returns a shallow copy of this &#123;@code ArrayList&#125; instance. (The * elements themselves are not copied.) * * @return a clone of this &#123;@code ArrayList&#125; instance */ public Object clone() &#123; try &#123; ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(e); &#125; &#125; /** * Returns an array containing all of the elements in this list * in proper sequence (from first to last element). * * &lt;p&gt;The returned array will be "safe" in that no references to it are * maintained by this list. (In other words, this method must allocate * a new array). The caller is thus free to modify the returned array. * * &lt;p&gt;This method acts as bridge between array-based and collection-based * APIs. * * @return an array containing all of the elements in this list in * proper sequence */ public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; /** * Returns an array containing all of the elements in this list in proper * sequence (from first to last element); the runtime type of the returned * array is that of the specified array. If the list fits in the * specified array, it is returned therein. Otherwise, a new array is * allocated with the runtime type of the specified array and the size of * this list. * * &lt;p&gt;If the list fits in the specified array with room to spare * (i.e., the array has more elements than the list), the element in * the array immediately following the end of the collection is set to * &#123;@code null&#125;. (This is useful in determining the length of the * list &lt;i&gt;only&lt;/i&gt; if the caller knows that the list does not contain * any null elements.) * * @param a the array into which the elements of the list are to * be stored, if it is big enough; otherwise, a new array of the * same runtime type is allocated for this purpose. * @return an array containing the elements of the list * @throws ArrayStoreException if the runtime type of the specified array * is not a supertype of the runtime type of every element in * this list * @throws NullPointerException if the specified array is null */ @SuppressWarnings("unchecked") public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; // Positional Access Operations @SuppressWarnings("unchecked") E elementData(int index) &#123; return (E) elementData[index]; &#125; @SuppressWarnings("unchecked") static &lt;E&gt; E elementAt(Object[] es, int index) &#123; return (E) es[index]; &#125; /** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E get(int index) &#123; Objects.checkIndex(index, size); return elementData(index); &#125; /** * Replaces the element at the specified position in this list with * the specified element. * * @param index index of the element to replace * @param element element to be stored at the specified position * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E set(int index, E element) &#123; Objects.checkIndex(index, size); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; /** * This helper method split out from add(E) to keep method * bytecode size under 35 (the -XX:MaxInlineSize default value), * which helps when add(E) is called in a C1-compiled loop. */ private void add(E e, Object[] elementData, int s) &#123; if (s == elementData.length) elementData = grow(); elementData[s] = e; size = s + 1; &#125; /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; modCount++; add(e, elementData, size); return true; &#125; /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public void add(int index, E element) &#123; rangeCheckForAdd(index); modCount++; final int s; Object[] elementData; if ((s = size) == (elementData = this.elementData).length) elementData = grow(); System.arraycopy(elementData, index, elementData, index + 1, s - index); elementData[index] = element; size = s + 1; &#125; /** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E remove(int index) &#123; Objects.checkIndex(index, size); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; /** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &#123;@code i&#125; such that * &#123;@code Objects.equals(o, get(i))&#125; * (if such an element exists). Returns &#123;@code true&#125; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &#123;@code true&#125; if this list contained the specified element */ public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; /** * Private remove method that skips bounds checking and does not * return the value removed. */ private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; /** * Removes all of the elements from this list. The list will * be empty after this call returns. */ public void clear() &#123; modCount++; final Object[] es = elementData; for (int to = size, i = size = 0; i &lt; to; i++) es[i] = null; &#125; /** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the * specified collection's Iterator. The behavior of this operation is * undefined if the specified collection is modified while the operation * is in progress. (This implies that the behavior of this call is * undefined if the specified collection is this list, and this * list is nonempty.) * * @param c collection containing elements to be added to this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); modCount++; int numNew = a.length; if (numNew == 0) return false; Object[] elementData; final int s; if (numNew &gt; (elementData = this.elementData).length - (s = size)) elementData = grow(s + numNew); System.arraycopy(a, 0, elementData, s, numNew); size = s + numNew; return true; &#125; /** * Inserts all of the elements in the specified collection into this * list, starting at the specified position. Shifts the element * currently at that position (if any) and any subsequent elements to * the right (increases their indices). The new elements will appear * in the list in the order that they are returned by the * specified collection's iterator. * * @param index index at which to insert the first element from the * specified collection * @param c collection containing elements to be added to this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws NullPointerException if the specified collection is null */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); modCount++; int numNew = a.length; if (numNew == 0) return false; Object[] elementData; final int s; if (numNew &gt; (elementData = this.elementData).length - (s = size)) elementData = grow(s + numNew); int numMoved = s - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size = s + numNew; return true; &#125; /** * Removes from this list all of the elements whose index is between * &#123;@code fromIndex&#125;, inclusive, and &#123;@code toIndex&#125;, exclusive. * Shifts any succeeding elements to the left (reduces their index). * This call shortens the list by &#123;@code (toIndex - fromIndex)&#125; elements. * (If &#123;@code toIndex==fromIndex&#125;, this operation has no effect.) * * @throws IndexOutOfBoundsException if &#123;@code fromIndex&#125; or * &#123;@code toIndex&#125; is out of range * (&#123;@code fromIndex &lt; 0 || * toIndex &gt; size() || * toIndex &lt; fromIndex&#125;) */ protected void removeRange(int fromIndex, int toIndex) &#123; if (fromIndex &gt; toIndex) &#123; throw new IndexOutOfBoundsException( outOfBoundsMsg(fromIndex, toIndex)); &#125; modCount++; shiftTailOverGap(elementData, fromIndex, toIndex); &#125; /** Erases the gap from lo to hi, by sliding down following elements. */ private void shiftTailOverGap(Object[] es, int lo, int hi) &#123; System.arraycopy(es, hi, es, lo, size - hi); for (int to = size, i = (size -= hi - lo); i &lt; to; i++) es[i] = null; &#125; /** * A version of rangeCheck used by add and addAll. */ private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * Constructs an IndexOutOfBoundsException detail message. * Of the many possible refactorings of the error handling code, * this "outlining" performs best with both server and client VMs. */ private String outOfBoundsMsg(int index) &#123; return "Index: "+index+", Size: "+size; &#125; /** * A version used in checking (fromIndex &gt; toIndex) condition */ private static String outOfBoundsMsg(int fromIndex, int toIndex) &#123; return "From Index: " + fromIndex + " &gt; To Index: " + toIndex; &#125; /** * Removes from this list all of its elements that are contained in the * specified collection. * * @param c collection containing elements to be removed from this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws ClassCastException if the class of an element of this list * is incompatible with the specified collection * (&lt;a href="Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) * @throws NullPointerException if this list contains a null element and the * specified collection does not permit null elements * (&lt;a href="Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;), * or if the specified collection is null * @see Collection#contains(Object) */ public boolean removeAll(Collection&lt;?&gt; c) &#123; return batchRemove(c, false, 0, size); &#125; /** * Retains only the elements in this list that are contained in the * specified collection. In other words, removes from this list all * of its elements that are not contained in the specified collection. * * @param c collection containing elements to be retained in this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws ClassCastException if the class of an element of this list * is incompatible with the specified collection * (&lt;a href="Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) * @throws NullPointerException if this list contains a null element and the * specified collection does not permit null elements * (&lt;a href="Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;), * or if the specified collection is null * @see Collection#contains(Object) */ public boolean retainAll(Collection&lt;?&gt; c) &#123; return batchRemove(c, true, 0, size); &#125; boolean batchRemove(Collection&lt;?&gt; c, boolean complement, final int from, final int end) &#123; Objects.requireNonNull(c); final Object[] es = elementData; final boolean modified; int r; // Optimize for initial run of survivors for (r = from; r &lt; end &amp;&amp; c.contains(es[r]) == complement; r++) ; if (modified = (r &lt; end)) &#123; int w = r++; try &#123; for (Object e; r &lt; end; r++) if (c.contains(e = es[r]) == complement) es[w++] = e; &#125; catch (Throwable ex) &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. System.arraycopy(es, r, es, w, end - r); w += end - r; throw ex; &#125; finally &#123; modCount += end - w; shiftTailOverGap(es, w, end); &#125; &#125; return modified; &#125; /** * Saves the state of the &#123;@code ArrayList&#125; instance to a stream * (that is, serializes it). * * @param s the stream * @throws java.io.IOException if an I/O error occurs * @serialData The length of the array backing the &#123;@code ArrayList&#125; * instance is emitted (int), followed by all of its elements * (each an &#123;@code Object&#125;) in the proper order. */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * Reconstitutes the &#123;@code ArrayList&#125; instance from a stream (that is, * deserializes it). * @param s the stream * @throws ClassNotFoundException if the class of a serialized object * could not be found * @throws java.io.IOException if an I/O error occurs */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // like clone(), allocate array based upon size not capacity SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size); Object[] elements = new Object[size]; // Read in all elements in the proper order. for (int i = 0; i &lt; size; i++) &#123; elements[i] = s.readObject(); &#125; elementData = elements; &#125; else if (size == 0) &#123; elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new java.io.InvalidObjectException("Invalid size: " + size); &#125; &#125; /** * Returns a list iterator over the elements in this list (in proper * sequence), starting at the specified position in the list. * The specified index indicates the first element that would be * returned by an initial call to &#123;@link ListIterator#next next&#125;. * An initial call to &#123;@link ListIterator#previous previous&#125; would * return the element with the specified index minus one. * * &lt;p&gt;The returned list iterator is &lt;a href="#fail-fast"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public ListIterator&lt;E&gt; listIterator(int index) &#123; rangeCheckForAdd(index); return new ListItr(index); &#125; /** * Returns a list iterator over the elements in this list (in proper * sequence). * * &lt;p&gt;The returned list iterator is &lt;a href="#fail-fast"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @see #listIterator(int) */ public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0); &#125; /** * Returns an iterator over the elements in this list in proper sequence. * * &lt;p&gt;The returned iterator is &lt;a href="#fail-fast"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @return an iterator over the elements in this list in proper sequence */ public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; /** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; // prevent creating a synthetic constructor Itr() &#123;&#125; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); final int size = ArrayList.this.size; int i = cursor; if (i &lt; size) &#123; final Object[] es = elementData; if (i &gt;= es.length) throw new ConcurrentModificationException(); for (; i &lt; size &amp;&amp; modCount == expectedModCount; i++) action.accept(elementAt(es, i)); // update once at end to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; /** * An optimized version of AbstractList.ListItr */ private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; @SuppressWarnings("unchecked") public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[lastRet = i]; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; ArrayList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; &#125; /** * Returns a view of the portion of this list between the specified * &#123;@code fromIndex&#125;, inclusive, and &#123;@code toIndex&#125;, exclusive. (If * &#123;@code fromIndex&#125; and &#123;@code toIndex&#125; are equal, the returned list is * empty.) The returned list is backed by this list, so non-structural * changes in the returned list are reflected in this list, and vice-versa. * The returned list supports all of the optional list operations. * * &lt;p&gt;This method eliminates the need for explicit range operations (of * the sort that commonly exist for arrays). Any operation that expects * a list can be used as a range operation by passing a subList view * instead of a whole list. For example, the following idiom * removes a range of elements from a list: * &lt;pre&gt; * list.subList(from, to).clear(); * &lt;/pre&gt; * Similar idioms may be constructed for &#123;@link #indexOf(Object)&#125; and * &#123;@link #lastIndexOf(Object)&#125;, and all of the algorithms in the * &#123;@link Collections&#125; class can be applied to a subList. * * &lt;p&gt;The semantics of the list returned by this method become undefined if * the backing list (i.e., this list) is &lt;i&gt;structurally modified&lt;/i&gt; in * any way other than via the returned list. (Structural modifications are * those that change the size of this list, or otherwise perturb it in such * a fashion that iterations in progress may yield incorrect results.) * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws IllegalArgumentException &#123;@inheritDoc&#125; */ public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList&lt;&gt;(this, fromIndex, toIndex); &#125; private static class SubList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess &#123; private final ArrayList&lt;E&gt; root; private final SubList&lt;E&gt; parent; private final int offset; private int size; /** * Constructs a sublist of an arbitrary ArrayList. */ public SubList(ArrayList&lt;E&gt; root, int fromIndex, int toIndex) &#123; this.root = root; this.parent = null; this.offset = fromIndex; this.size = toIndex - fromIndex; this.modCount = root.modCount; &#125; /** * Constructs a sublist of another SubList. */ private SubList(SubList&lt;E&gt; parent, int fromIndex, int toIndex) &#123; this.root = parent.root; this.parent = parent; this.offset = parent.offset + fromIndex; this.size = toIndex - fromIndex; this.modCount = root.modCount; &#125; public E set(int index, E element) &#123; Objects.checkIndex(index, size); checkForComodification(); E oldValue = root.elementData(offset + index); root.elementData[offset + index] = element; return oldValue; &#125; public E get(int index) &#123; Objects.checkIndex(index, size); checkForComodification(); return root.elementData(offset + index); &#125; public int size() &#123; checkForComodification(); return size; &#125; public void add(int index, E element) &#123; rangeCheckForAdd(index); checkForComodification(); root.add(offset + index, element); updateSizeAndModCount(1); &#125; public E remove(int index) &#123; Objects.checkIndex(index, size); checkForComodification(); E result = root.remove(offset + index); updateSizeAndModCount(-1); return result; &#125; protected void removeRange(int fromIndex, int toIndex) &#123; checkForComodification(); root.removeRange(offset + fromIndex, offset + toIndex); updateSizeAndModCount(fromIndex - toIndex); &#125; public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(this.size, c); &#125; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); int cSize = c.size(); if (cSize==0) return false; checkForComodification(); root.addAll(offset + index, c); updateSizeAndModCount(cSize); return true; &#125; public boolean removeAll(Collection&lt;?&gt; c) &#123; return batchRemove(c, false); &#125; public boolean retainAll(Collection&lt;?&gt; c) &#123; return batchRemove(c, true); &#125; private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; checkForComodification(); int oldSize = root.size; boolean modified = root.batchRemove(c, complement, offset, offset + size); if (modified) updateSizeAndModCount(root.size - oldSize); return modified; &#125; public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; checkForComodification(); int oldSize = root.size; boolean modified = root.removeIf(filter, offset, offset + size); if (modified) updateSizeAndModCount(root.size - oldSize); return modified; &#125; public Iterator&lt;E&gt; iterator() &#123; return listIterator(); &#125; public ListIterator&lt;E&gt; listIterator(int index) &#123; checkForComodification(); rangeCheckForAdd(index); return new ListIterator&lt;E&gt;() &#123; int cursor = index; int lastRet = -1; int expectedModCount = root.modCount; public boolean hasNext() &#123; return cursor != SubList.this.size; &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= SubList.this.size) throw new NoSuchElementException(); Object[] elementData = root.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[offset + (lastRet = i)]; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; @SuppressWarnings("unchecked") public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = root.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[offset + (lastRet = i)]; &#125; public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); final int size = SubList.this.size; int i = cursor; if (i &lt; size) &#123; final Object[] es = root.elementData; if (offset + i &gt;= es.length) throw new ConcurrentModificationException(); for (; i &lt; size &amp;&amp; modCount == expectedModCount; i++) action.accept(elementAt(es, offset + i)); // update once at end to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; SubList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = root.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; root.set(offset + lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; SubList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = root.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (root.modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125;; &#125; public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList&lt;&gt;(this, fromIndex, toIndex); &#125; private void rangeCheckForAdd(int index) &#123; if (index &lt; 0 || index &gt; this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private String outOfBoundsMsg(int index) &#123; return "Index: "+index+", Size: "+this.size; &#125; private void checkForComodification() &#123; if (root.modCount != modCount) throw new ConcurrentModificationException(); &#125; private void updateSizeAndModCount(int sizeChange) &#123; SubList&lt;E&gt; slist = this; do &#123; slist.size += sizeChange; slist.modCount = root.modCount; slist = slist.parent; &#125; while (slist != null); &#125; public Spliterator&lt;E&gt; spliterator() &#123; checkForComodification(); // ArrayListSpliterator not used here due to late-binding return new Spliterator&lt;E&gt;() &#123; private int index = offset; // current index, modified on advance/split private int fence = -1; // -1 until used; then one past last index private int expectedModCount; // initialized when fence set private int getFence() &#123; // initialize fence to size on first use int hi; // (a specialized variant appears in method forEach) if ((hi = fence) &lt; 0) &#123; expectedModCount = modCount; hi = fence = offset + size; &#125; return hi; &#125; public ArrayList&lt;E&gt;.ArrayListSpliterator trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; // ArrayListSpliterator can be used here as the source is already bound return (lo &gt;= mid) ? null : // divide range in half unless too small root.new ArrayListSpliterator(lo, index = mid, expectedModCount); &#125; public boolean tryAdvance(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); int hi = getFence(), i = index; if (i &lt; hi) &#123; index = i + 1; @SuppressWarnings("unchecked") E e = (E)root.elementData[i]; action.accept(e); if (root.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; return false; &#125; public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); int i, hi, mc; // hoist accesses and checks from loop ArrayList&lt;E&gt; lst = root; Object[] a; if ((a = lst.elementData) != null) &#123; if ((hi = fence) &lt; 0) &#123; mc = modCount; hi = offset + size; &#125; else mc = expectedModCount; if ((i = index) &gt;= 0 &amp;&amp; (index = hi) &lt;= a.length) &#123; for (; i &lt; hi; ++i) &#123; @SuppressWarnings("unchecked") E e = (E) a[i]; action.accept(e); &#125; if (lst.modCount == mc) return; &#125; &#125; throw new ConcurrentModificationException(); &#125; public long estimateSize() &#123; return getFence() - index; &#125; public int characteristics() &#123; return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED; &#125; &#125;; &#125; &#125; /** * @throws NullPointerException &#123;@inheritDoc&#125; */ @Override public void forEach(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); final int expectedModCount = modCount; final Object[] es = elementData; final int size = this.size; for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) action.accept(elementAt(es, i)); if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; /** * Creates a &lt;em&gt;&lt;a href="Spliterator.html#binding"&gt;late-binding&lt;/a&gt;&lt;/em&gt; * and &lt;em&gt;fail-fast&lt;/em&gt; &#123;@link Spliterator&#125; over the elements in this * list. * * &lt;p&gt;The &#123;@code Spliterator&#125; reports &#123;@link Spliterator#SIZED&#125;, * &#123;@link Spliterator#SUBSIZED&#125;, and &#123;@link Spliterator#ORDERED&#125;. * Overriding implementations should document the reporting of additional * characteristic values. * * @return a &#123;@code Spliterator&#125; over the elements in this list * @since 1.8 */ @Override public Spliterator&lt;E&gt; spliterator() &#123; return new ArrayListSpliterator(0, -1, 0); &#125; /** Index-based split-by-two, lazily initialized Spliterator */ final class ArrayListSpliterator implements Spliterator&lt;E&gt; &#123; /* * If ArrayLists were immutable, or structurally immutable (no * adds, removes, etc), we could implement their spliterators * with Arrays.spliterator. Instead we detect as much * interference during traversal as practical without * sacrificing much performance. We rely primarily on * modCounts. These are not guaranteed to detect concurrency * violations, and are sometimes overly conservative about * within-thread interference, but detect enough problems to * be worthwhile in practice. To carry this out, we (1) lazily * initialize fence and expectedModCount until the latest * point that we need to commit to the state we are checking * against; thus improving precision. (This doesn't apply to * SubLists, that create spliterators with current non-lazy * values). (2) We perform only a single * ConcurrentModificationException check at the end of forEach * (the most performance-sensitive method). When using forEach * (as opposed to iterators), we can normally only detect * interference after actions, not before. Further * CME-triggering checks apply to all other possible * violations of assumptions for example null or too-small * elementData array given its size(), that could only have * occurred due to interference. This allows the inner loop * of forEach to run without any further checks, and * simplifies lambda-resolution. While this does entail a * number of checks, note that in the common case of * list.stream().forEach(a), no checks or other computation * occur anywhere other than inside forEach itself. The other * less-often-used methods cannot take advantage of most of * these streamlinings. */ private int index; // current index, modified on advance/split private int fence; // -1 until used; then one past last index private int expectedModCount; // initialized when fence set /** Creates new spliterator covering the given range. */ ArrayListSpliterator(int origin, int fence, int expectedModCount) &#123; this.index = origin; this.fence = fence; this.expectedModCount = expectedModCount; &#125; private int getFence() &#123; // initialize fence to size on first use int hi; // (a specialized variant appears in method forEach) if ((hi = fence) &lt; 0) &#123; expectedModCount = modCount; hi = fence = size; &#125; return hi; &#125; public ArrayListSpliterator trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid) ? null : // divide range in half unless too small new ArrayListSpliterator(lo, index = mid, expectedModCount); &#125; public boolean tryAdvance(Consumer&lt;? super E&gt; action) &#123; if (action == null) throw new NullPointerException(); int hi = getFence(), i = index; if (i &lt; hi) &#123; index = i + 1; @SuppressWarnings("unchecked") E e = (E)elementData[i]; action.accept(e); if (modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; return false; &#125; public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; int i, hi, mc; // hoist accesses and checks from loop Object[] a; if (action == null) throw new NullPointerException(); if ((a = elementData) != null) &#123; if ((hi = fence) &lt; 0) &#123; mc = modCount; hi = size; &#125; else mc = expectedModCount; if ((i = index) &gt;= 0 &amp;&amp; (index = hi) &lt;= a.length) &#123; for (; i &lt; hi; ++i) &#123; @SuppressWarnings("unchecked") E e = (E) a[i]; action.accept(e); &#125; if (modCount == mc) return; &#125; &#125; throw new ConcurrentModificationException(); &#125; public long estimateSize() &#123; return getFence() - index; &#125; public int characteristics() &#123; return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED; &#125; &#125; // A tiny bit set implementation private static long[] nBits(int n) &#123; return new long[((n - 1) &gt;&gt; 6) + 1]; &#125; private static void setBit(long[] bits, int i) &#123; bits[i &gt;&gt; 6] |= 1L &lt;&lt; i; &#125; private static boolean isClear(long[] bits, int i) &#123; return (bits[i &gt;&gt; 6] &amp; (1L &lt;&lt; i)) == 0; &#125; /** * @throws NullPointerException &#123;@inheritDoc&#125; */ @Override public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; return removeIf(filter, 0, size); &#125; /** * Removes all elements satisfying the given predicate, from index * i (inclusive) to index end (exclusive). */ boolean removeIf(Predicate&lt;? super E&gt; filter, int i, final int end) &#123; Objects.requireNonNull(filter); int expectedModCount = modCount; final Object[] es = elementData; // Optimize for initial run of survivors for (; i &lt; end &amp;&amp; !filter.test(elementAt(es, i)); i++) ; // Tolerate predicates that reentrantly access the collection for // read (but writers still get CME), so traverse once to find // elements to delete, a second pass to physically expunge. if (i &lt; end) &#123; final int beg = i; final long[] deathRow = nBits(end - beg); deathRow[0] = 1L; // set bit 0 for (i = beg + 1; i &lt; end; i++) if (filter.test(elementAt(es, i))) setBit(deathRow, i - beg); if (modCount != expectedModCount) throw new ConcurrentModificationException(); expectedModCount++; modCount++; int w = beg; for (i = beg; i &lt; end; i++) if (isClear(deathRow, i - beg)) es[w++] = es[i]; shiftTailOverGap(es, w, end); return true; &#125; else &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); return false; &#125; &#125; @Override public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); final int expectedModCount = modCount; final Object[] es = elementData; final int size = this.size; for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) es[i] = operator.apply(elementAt(es, i)); if (modCount != expectedModCount) throw new ConcurrentModificationException(); modCount++; &#125; @Override @SuppressWarnings("unchecked") public void sort(Comparator&lt;? super E&gt; c) &#123; final int expectedModCount = modCount; Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) throw new ConcurrentModificationException(); modCount++; &#125; void checkInvariants() &#123; // assert size &gt;= 0; // assert size == elementData.length || elementData[size] == null; &#125;&#125;]]></content>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9--动态SQLr-foreach]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F9---%E5%8A%A8%E6%80%81SQL--foreach%2F</url>
    <content type="text"><![CDATA[foreach需要注意一点的是:collection为set list array时，index为集合的下标, item为元素值collection为map时，index为key,item为valuedao 1List&lt;Student&gt; listStudents(List&lt;Integer&gt; list); mapper 12345678&lt;select id="listStudents" resultMap="studentMapper"&gt; select * from `student` where `id` in &lt;foreach collection="list" item="value" index="indexOrKey" open="(" separator="," close=")"&gt; #&#123;value&#125; &lt;/foreach&gt; &lt;/select&gt; test 12345678910111213141516171819202122@Testpublic void test() &#123; SqlSession session = factory.openSession(); try &#123; StudentMapper studentMapper = session.getMapper(StudentMapper.class); List&lt;Integer&gt; listIds = new ArrayList&lt;&gt;(); listIds.add(1000); listIds.add(10001); List&lt;Student&gt; students = studentMapper.listStudents(listIds); if(!students.isEmpty())&#123; for (Student student: students) &#123; System.out.println(student); &#125; &#125;else&#123; System.out.println("没有查到结果!"); &#125; &#125; finally &#123; session.commit(); session.close(); &#125;&#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[8-动态SQLr-set]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F8---%E5%8A%A8%E6%80%81SQL--set%2F</url>
    <content type="text"><![CDATA[set ifdao 1int updateStudent(Student student); mapper 123456789101112131415&lt;update id="updateStudent" parameterType="student"&gt; update `student` &lt;set&gt; &lt;if test="name != null"&gt; `name` = #&#123;name&#125;, &lt;/if&gt; &lt;if test="age != null"&gt; `age` = #&#123;age&#125;, &lt;/if&gt; &lt;if test="gender != null"&gt; `gender` = #&#123;gender,typeHandler=genderTypeHandler&#125; &lt;/if&gt; &lt;/set&gt; where `id` = #&#123;id&#125; &lt;/update&gt; test 12345678910111213141516171819@Testpublic void test() &#123; SqlSession session = factory.openSession(); try &#123; StudentMapper studentMapper = session.getMapper(StudentMapper.class); int id = 10001; String name = "hu"; int age = 18; GenderEnum gender = GenderEnum.getGender(1); Student student = new Student(id,name,age,gender); int affectedRows = studentMapper.updateStudent(student); System.out.println(affectedRows); System.out.println(studentMapper.selectStudentById(id)); &#125; finally &#123; session.commit(); session.close(); &#125;&#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[7--动态SQLr-where]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F7---%E5%8A%A8%E6%80%81SQL--where%2F</url>
    <content type="text"><![CDATA[where ifdao在含有int类型的查询参数，最好设置为Integer,以便接收null值 123List&lt;Student&gt; selectStudents(@Param("name") String name, @Param("age") Integer age, @Param("gender") GenderEnum gender); mapper 1234567891011121314&lt;select id="selectStudents" resultMap="studentMapper"&gt; select * from `student` &lt;where&gt; &lt;if test="name != null"&gt; `name` like concat('%',#&#123;name&#125;,'%') &lt;/if&gt; &lt;if test="age != null"&gt; and `age` = #&#123;age&#125; &lt;/if&gt; &lt;if test="gender != null"&gt; and `gender` = #&#123;gender,typeHandler=genderTypeHandler&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; test 1234567891011121314151617181920212223242526272829@Test public void test() &#123; SqlSession session = factory.openSession(); try &#123; StudentMapper studentMapper = session.getMapper(StudentMapper.class);// Student student = new Student("hu",19,GenderEnum.getGender(1));// int affectedRows = studentMapper.insertStudent(student); String name = "h"; int age = 20; GenderEnum gender = GenderEnum.getGender(2); List&lt;Student&gt; students = studentMapper.selectStudents(name, age,gender);// List&lt;Student&gt; students = studentMapper.selectStudents(name, age,null);// List&lt;Student&gt; students = studentMapper.selectStudents(name, null,gender);// List&lt;Student&gt; students = studentMapper.selectStudents(name, null,null);// List&lt;Student&gt; students = studentMapper.selectStudents(null, null,null); if(!students.isEmpty())&#123; Iterator&lt;Student&gt; it = students.iterator(); while(it.hasNext())&#123; Student student = it.next(); System.out.println(student); &#125; &#125;else&#123; System.out.println("没有查到结果"); &#125; &#125; finally &#123; session.commit(); session.close(); &#125; &#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[6--TypeHandler-2]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F6---TypeHandler-2%2F</url>
    <content type="text"><![CDATA[本小节对枚举类型进行转换table 123456create table `student`(`id` int auto_increment primary key,`name` varchar(30) not null,`age` int,`gender` int default 0)auto_increment=10000; enum 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package model;public enum GenderEnum &#123; MALE("男",0),FEMALE("女",1),UNKNOW("不知道",2); private String gender; private int code; GenderEnum(String gender, int code)&#123; this.gender = gender; this.code = code; &#125; public static GenderEnum getGender(String genderName)&#123; for (GenderEnum gender: GenderEnum.values())&#123; if(gender.gender.equalsIgnoreCase(genderName))&#123; return gender; &#125; &#125; return null; &#125; public static GenderEnum getGender(int code)&#123; for (GenderEnum gender: GenderEnum.values())&#123; if(gender.code == code)&#123; return gender; &#125; &#125; return null; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; @Override public String toString() &#123; return "GenderEnum&#123;" + "gender='" + gender + '\'' + ", code=" + code + '&#125;'; &#125;&#125; model 12345678910111213package model;public class Student &#123; private int id; private String name; private int age; private GenderEnum gender; public Student() &#123; &#125; //getter setter &#125; dao 1234public interface StudentMapper &#123; int insertStudent(Student student); Student selectStudentById(int id);&#125; mapper这里的typeHandler使用了别名 123456789101112131415161718&lt;insert id="insertStudent" parameterType="student"&gt; insert into `student`(`name`,`age`,`gender`) values(#&#123;name&#125;,#&#123;age&#125;,#&#123;gender,typeHandler=genderTypeHandler&#125;) &lt;selectKey resultType="int" keyColumn="id" keyProperty="id" order="AFTER"&gt; select last_insert_id(); &lt;/selectKey&gt; &lt;/insert&gt; &lt;resultMap id="studentMapper" type="student"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="name" column="name"/&gt; &lt;result property="age" column="age"/&gt; &lt;result property="gender" column="gender" typeHandler="genderTypeHandler"/&gt; &lt;/resultMap&gt; &lt;select id="selectStudentById" parameterType="int" resultMap="studentMapper"&gt; select * from `student` where `id` = #&#123;id&#125; &lt;/select&gt; test 12]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[5--TypeHandler-1]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F5---TypeHandler-1%2F</url>
    <content type="text"><![CDATA[当需要将jdbc类型的数据和Java程序中类型的书数据进行转换时，可以使用TypeHandler来完成转换过程。怎么实现呢?Java类型==》jdbc将Java类型值value1通过某种策略转化为数据库(jdbc)类型值value2，然后将value2设置为SQL参数 :preparedStatement.setType(i,value2);Java类型《== jdbc从resultSet中取出值value2，然后通过某种策略将value2转换为Java类型值value1 table123456create table `student`(`id` int auto_increment primary key,`name` varchar(30) not null,`age` int,`birthday` varchar(30))auto_increment=10000; model123456789101112131415package model;import java.util.Date;public class Student &#123; private int id; private String name; private int age; private Date birthday;//在数据库中对应的类型是varchar(n) public Student() &#123; &#125;//getter和setter略&#125; TypeHandler123456789101112131415161718192021222324252627//表注转换的两种类型@MappedJdbcTypes(&#123;JdbcType.VARCHAR&#125;)//jdbc类型@MappedTypes(&#123;java.util.Date.class&#125;)//程序类型public class MyDateTypeHandler extends BaseTypeHandler&lt;Date&gt; &#123; @Override public void setNonNullParameter(PreparedStatement preparedStatement, int i, Date date, JdbcType jdbcType) throws SQLException &#123; preparedStatement.setString(i,String.valueOf(date.getTime())); &#125; @Override public Date getNullableResult(ResultSet resultSet, int i) throws SQLException &#123; return new Date(resultSet.getLong(i)); &#125; @Override public Date getNullableResult(ResultSet resultSet, String s) throws SQLException &#123; return new Date(resultSet.getLong(s)); &#125; @Override public Date getNullableResult(CallableStatement callableStatement, int i) throws SQLException &#123; return new Date(callableStatement.getLong(i)); &#125;&#125; dao12345678910package dao;import model.Student;public interface StudentMapper &#123; int insertStudent(Student student); Student selectStudentById(int id);&#125; mapper在对应参数处使用typeHandler来转换作为输入参数:#{birthday,typeHandler=dao.MyDateTypeHandler}这里的typeHandler的值不成写成字符串类型作为输出结果:&lt;result property=&quot;birthday&quot; column=&quot;birthday&quot; typeHandler=&quot;dao.MyDateTypeHandler&quot;/&gt; 123456789101112131415161718&lt;insert id="insertStudent" parameterType="student"&gt; insert into `student`(`name`,`age`,`birthday`) values(#&#123;name&#125;,#&#123;age&#125;,#&#123;birthday,typeHandler=dao.MyDateTypeHandler&#125;) &lt;selectKey resultType="int" keyProperty="id" keyColumn="id" order="AFTER"&gt; select last_insert_id() &lt;/selectKey&gt; &lt;/insert&gt; &lt;resultMap id="studentMapper" type="student"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="name" column="name"/&gt; &lt;result property="age" column="age"/&gt; &lt;result property="birthday" column="birthday" typeHandler="dao.MyDateTypeHandler"/&gt; &lt;/resultMap&gt; &lt;select id="selectStudentById" parameterType="int" resultMap="studentMapper"&gt; select * from `student` where `id` = #&#123;id&#125; &lt;/select&gt; test1234567891011121314151617181920212223242526272829public class AppTest &#123; SqlSessionFactory factory = null; @Before public void prepare() throws IOException&#123; InputStream inputStream = Resources.getResourceAsStream("mybatis.xml"); factory = new SqlSessionFactoryBuilder().build(inputStream); inputStream.close(); &#125; @Test public void test()&#123; SqlSession session = factory.openSession(); try&#123; StudentMapper studentMapper = session.getMapper(StudentMapper.class);// Student student = new Student("wang",20,new Date());// int affectedRows = studentMapper.insertStudent(student); int id=10001; Student student = studentMapper.selectStudentById(id); System.out.println(student); &#125;finally&#123; session.commit(); session.close(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[4--一对一]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F4---%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2~%E4%B8%80%E5%AF%B9%E4%B8%80%2F</url>
    <content type="text"><![CDATA[一本书只属于一个人!table 123456789101112create table `student`(`id` int auto_increment primary key,`name` varchar(30) not null,`age` int)auto_increment=10000;create table `book`(`id` int auto_increment primary key,`bookName` varchar(20),`author` varchar(10),`studentID` int references `student`(`id`))auto_increment=10000; model 123456789101112131415161718192021public class Student &#123; private int id; private String name; private int age; public Student()&#123;&#125; //getter setter略&#125;public class Book &#123; private int bookID; private String bookName; private String author; private Student student; public Book() &#123; &#125; //getter setter略&#125; dao 123public interface StudentMapper &#123; Book findBook(int bookID);&#125; mapper.xml方式一：嵌套 12345678910111213141516171819202122&lt;resultMap id="bookMapper" type="book"&gt; &lt;id column="bookID" property="bookID"/&gt; &lt;result column="bookName" property="bookName"/&gt; &lt;result column="author" property="author"/&gt; &lt;association property="student" javaType="student"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;result column="age" property="age"/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id="findBook" resultMap="bookMapper"&gt; select `student`.`id` `id`,`student`.`name` `name`, `student`.`age` `age`, `book`.`id` `bookID`, `book`.`bookName` `bookName`, `book`.`author` `author` from `student`,`book` where `student`.`id` = `book`.`studentID` and `book`.`id` = #&#123;bookID&#125;;&lt;/select&gt; 方式二:复用resultMapper 123456789101112131415161718192021222324 &lt;select id="findBook" resultMap="bookMapper"&gt; select `student`.`id` `id`, `student`.`name` `name`, `student`.`age` `age`, `book`.`id` `bookID`, `book`.`bookName` `bookName`, `book`.`author` `author` from `student`,`book` where `student`.`id` = `book`.`studentID` and `book`.`id` = #&#123;bookID&#125;; &lt;/select&gt;&lt;resultMap id="studentMapper" type="student"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;result column="age" property="age"/&gt; &lt;/resultMap&gt; &lt;resultMap id="bookMapper" type="book"&gt; &lt;id column="bookID" property="bookID"/&gt; &lt;result column="bookName" property="bookName"/&gt; &lt;result column="author" property="author"/&gt; &lt;association property="student" resultMap="studentMapper"/&gt; &lt;/resultMap&gt; 综合3、4关联查询两篇文章，总结一下1.明确实体之间的关系，优化范式，构建表2.依据业务，构建model3.编写关联查询语句 首先编写简单的model开始，建议使用resutlMap来映射，因为当SQL复杂时，嵌套很容易出错。然后依据一对一association或一对多collection来创建复杂实体。最后编写关联查询语句，注意返回字段的名称。需要注意两点: resultMap中的column属性必须和数据库返回字段相同 resultMap中的property属性必须和Model的成员属性相同]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[3--关联查询~一对多]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F3---%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2~%E4%B8%80%E5%AF%B9%E5%A4%9A%2F</url>
    <content type="text"><![CDATA[本小节将要介绍一对一、一对多的查询【技术上】。你有可能会问，多对多怎么查，这个问题就不该问！开玩笑的，哈哈。其实在设计表时，一般多对多的关系就已经转化为一对多了。 ###一对多就用一个学生有多本书籍来举例子吧!table 123456789101112create table `student`(`id` int auto_increment primary key,`name` varchar(30) not null,`age` int)auto_increment=10000;create table `book`(`id` int auto_increment primary key,`bookName` varchar(20),`author` varchar(10),`studentID` int references `student`(`id`))auto_increment=10000; model 123456789101112131415161718192021public class Student &#123; private int id; private String name; private int age; private List&lt;Book&gt; books; public Student() &#123;//无参构造函数===&gt;创建对象 &#125;//getter和setter略&#125;public class Book &#123; private int bookID; private String bookName; private String author; public Book() &#123; &#125;&#125;//getter和setter略 dao 123public interface StudentMapper &#123; Student findMyBooks(int id);&#125; mapple.xml方式一，直接嵌套 12345678910111213141516171819202122&lt;select id="findMyBooks" resultMap="studentMapper"&gt; select `student`.`id` `id`,`student`.`name` `name`, `student`.`age` `age`, `book`.`id` `bookID`, `book`.`bookName` `bookName`, `book`.`author` `author` from `student`,`book` where `student`.`id` = `book`.`studentID` and `student`.`id` = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id="studentMapper" type="student"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="name" column="name"/&gt; &lt;result property="age" column="age"/&gt; &lt;collection property="books" ofType="book"&gt; &lt;id property="bookID" column="bookID"/&gt; &lt;result property="bookName" column="bookName"/&gt; &lt;result property="author" column="author"/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 方式二：resultMap复用 123456789101112131415161718192021222324&lt;select id="findMyBooks" resultMap="studentMapper"&gt; select `student`.`id` `id`,`student`.`name` `name`, `student`.`age` `age`, `book`.`id` `bookID`, `book`.`bookName` `bookName`, `book`.`author` `author` from `student`,`book` where `student`.`id` = `book`.`studentID` and `student`.`id` = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id="bookMapper" type="book"&gt; &lt;id property="bookID" column="bookID"/&gt; &lt;result property="bookName" column="bookName"/&gt; &lt;result property="author" column="author"/&gt;&lt;/resultMap&gt;&lt;resultMap id="studentMapper" type="student"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="name" column="name"/&gt; &lt;result property="age" column="age"/&gt; &lt;collection property="books" resultMap="bookMapper"/&gt;&lt;/resultMap&gt; 关联查询必须用无参构造函数来创建对象，如果没有无参构造函数，就会报构造函数参数错误。希望能引起你的警觉。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1--基本CRUD]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F2---%E5%9F%BA%E6%9C%ACCURD%2F</url>
    <content type="text"><![CDATA[dao 123456789101112131415161718package dao;import model.Student;import java.util.List;public interface StudentMapper &#123; List&lt;Student&gt; selectAllStudent(); int insertStudent(Student student); int updateStudent(Student student); int deleteById(int id);&#125;​` mapple.xml 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="dao.StudentMapper"&gt; &lt;select id="selectAllStudent" resultType="student"&gt; select * from `student` &lt;/select&gt; &lt;insert id="insertStudent" parameterType="student"&gt; insert into `student`(`name`,`age`) values(#&#123;name&#125;,#&#123;age&#125;) &lt;selectKey resultType="int" keyColumn="id" keyProperty="id" order="AFTER"&gt; select last_insert_id(); &lt;/selectKey&gt; &lt;/insert&gt; &lt;update id="updateStudent" parameterType="student"&gt; update `student` set `name` = #&#123;name&#125;,`age` = #&#123;age&#125; where `id` = #&#123;id&#125; &lt;/update&gt; &lt;delete id="deleteById" parameterType="int"&gt; delete from `student` where `id` = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import dao.StudentMapper;import model.Student;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Iterator;import java.util.List;public class AppTest &#123; SqlSessionFactory factory = null; @Before public void prepare() throws IOException&#123; InputStream inputStream = Resources.getResourceAsStream("mybatis.xml"); factory = new SqlSessionFactoryBuilder().build(inputStream); inputStream.close(); &#125; @Test public void test()&#123; SqlSession session= factory.openSession(); try&#123; StudentMapper studentMapper = session.getMapper(StudentMapper.class); List&lt;Student&gt; list = studentMapper.selectAllStudent(); Iterator&lt;Student&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; Student student = iterator.next(); System.out.println(student); &#125; &#125;finally&#123; session.commit(); session.close(); &#125; &#125; @Test public void testInsert()&#123; SqlSession sqlSession = factory.openSession(); try&#123; StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); Student student = new Student("young",20); int affectedRows = studentMapper.insertStudent(student); if(affectedRows==1)&#123; System.out.println("插入成功!"); System.out.println(student);//查看从数据库返回id填充student的id属性 &#125;else&#123; System.out.println("插入失败!"); &#125; &#125;finally &#123; sqlSession.commit(); sqlSession.close(); &#125; &#125; @Test public void testUpdate()&#123; SqlSession sqlSession = factory.openSession(); try&#123; StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); Student student = new Student(10000,"Tom",21); int affectedRows = studentMapper.updateStudent(student); if(affectedRows != 0)&#123; System.out.println("更新成功!"); System.out.println(student); &#125;else&#123; System.out.println("更新失败"); &#125; &#125;finally &#123; sqlSession.commit(); sqlSession.close(); &#125; &#125; @Test public void testDelete()&#123; SqlSession sqlSession = factory.openSession(); try&#123; StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); int id = 10000; int affectedRows = studentMapper.deleteById(id); if(affectedRows == 1)&#123; System.out.println("删除成功!"); &#125;else&#123; System.out.println("删除失败!"); &#125; &#125;finally &#123; sqlSession.commit(); sqlSession.close(); &#125; &#125;&#125; 注意 插入、删除、修改要获取数据库中受影响的记录数，以便验证操作是否成功 插入一条数据最好返回从数据库返回生成的ID来给model的id赋值，以便后续使用 ```]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1--搭建环境]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F1---%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[####一.单独使用Mybaitsjar包测试:junit数据库驱动: mysql-connector-javaMybatis: mybatislog4j: log4j-core log4j-api1.创建db,properties 1234database.driver=com.mysql.jdbc.Driverdatabase.url=jdbc:mysql://localhost:3306/dbName?serverTimezone=UTC database.username=rootdatabase.password=*** 2.配置mybatis.xml 12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--要注意该文件的节点顺序，否则会报错--&gt; &lt;!--引入属性文件--&gt; &lt;properties resource="db.properties"/&gt; &lt;settings&gt; &lt;!--配置日志,固定写法--&gt; &lt;setting name="logImpl" value="LOG4J2"&gt;&lt;/setting&gt; &lt;/settings&gt; &lt;!--给实体取别名--&gt; &lt;typeAliases&gt; &lt;package name="dao"/&gt; &lt;package name="model"/&gt; &lt;/typeAliases&gt; &lt;!--数据源配置--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;database.driver&#125;"/&gt; &lt;property name="url" value="$&#123;database.url&#125;"/&gt; &lt;property name="username" value="$&#123;database.username&#125;"/&gt; &lt;property name="password" value="$&#123;database.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入mapple文件--&gt; &lt;mappers &gt; &lt;mapper resource="mapple/studentMapple.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 3.日志 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;Configuration status="WARN"&gt; &lt;Appenders&gt; &lt;Console name="console" target="SYSTEM_OUT"&gt; &lt;PatternLayout pattern="%d&#123;HH:mm:ss&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n"/&gt; &lt;/Console&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt; &lt;logger name="org.springframework" level="INFO"&gt;&lt;/logger&gt; &lt;logger name="org.mybatis" level="INFO"&gt;&lt;/logger&gt; &lt;root level="debug"&gt; &lt;appender-ref ref="console"/&gt; &lt;/root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 4.dao和model 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package dao;import model.Student;import java.util.List;public interface StudentMapper &#123; List&lt;Student&gt; selectAllStudent();&#125;package model;public class Student &#123; private int id; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Student&#123;" + "id=" + id + ", name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 5.mapple 12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="dao.StudentMapper"&gt; &lt;select id="selectAllStudent" resultType="student"&gt; select * from `student` &lt;/select&gt;&lt;/mapper&gt; 6.测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344import dao.StudentMapper;import model.Student;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Iterator;import java.util.List;public class AppTest &#123; SqlSessionFactory factory = null; @Before public void prepare() throws IOException&#123; InputStream inputStream = Resources.getResourceAsStream("mybatis.xml"); factory = new SqlSessionFactoryBuilder().build(inputStream); inputStream.close(); &#125; @Test public void test()&#123; SqlSession session= factory.openSession(); try&#123; StudentMapper studentMapper = session.getMapper(StudentMapper.class); List&lt;Student&gt; list = studentMapper.selectAllStudent(); Iterator&lt;Student&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; Student student = iterator.next(); System.out.println(student); &#125; &#125;finally&#123; session.commit(); session.close(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
</search>
