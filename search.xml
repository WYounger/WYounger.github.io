<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F31%2Fservlet-jsp%2F%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E4%B8%8E%E8%AF%B7%E6%B1%82%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[这个问题对于J2EE的初学者都会遇到，那么下面就从数据传递方向和用法简单聊一下，个人拙见！相同点：二者都是封装在request中 param: JSP–&gt;Servlet [客户端] String getParameter(String name)，即只能返回String类型数据。 setParameter()这一说。 attribute:Servlet–&gt;Servlet/JSP [容器内] void setAttribute(String name,Obejct o); Object getAttribute(String name); 先在request中set，然后才能在request中get]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F31%2Fservlet-jsp%2F%E7%9B%91%E5%90%AC%E5%99%A8%2F</url>
    <content type="text"><![CDATA[首先只需了解有哪些监听器，主要监听器由什么事件触发即可 #API]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F31%2Fservlet-jsp%2F%E5%BA%94%E7%94%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[一、简单流程图 二、容器####1、什么是容器Servlet没有main()方法。它们受控于另一个Java应用，这个Java应用称为容器。Tomcat就是一个容器。如果web服务器应用收到一个指向某servlet的请求，此时服务器不是把这个请求直接交给servlet本身，而是交给部署该servlet的容器。再由容器调用servlet的方法，如doPost()或doGet() ####2、容器的作用(1)利用容器提供的方法，可以轻松让servlet与Web服务器对话，屏蔽掉网络底层，使程序员更加专注业务本身。(2)容器控制着servlet的生与死。它会加载类、实例化和初始化servlet、调用servlet的方法，并使servlet对象能够被垃圾回收。(3)容器会为每一个servlet请求创建一个Java线程 ###三、容器处理请求简要过程:容器收到一个servlet请求,随后将request封装为HttpServletRequest和HttpServletResponse对象。根据URL映射到一个servlet，并为请求创建或分配一个线程，HttpservletRequest对象和HttpsevletResponse对象被传递给servlet线程。然后容器调用servlet的service方法，service方法依据时请求方法get还是post，调用doGet或doPost方法。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F31%2Fservlet-jsp%2F%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[####什么是属性 属性就是一个对象，可以设置到（绑定）到另外3个servlet API对象中的一个，包括ServletContext、HttpSession、HttpServletRequest(ServletRequest)。可以简单的认为是一个映射实例对象中的名/值(名–String，值–Obeject)。属性不是参数 ####三个作用域 ####属性API ####属性安全问题作用域在ServletContext的属性显然不安全，因为webapp的所有线程都可以访问处理。再想一想，HttpSession的属性是不是安全的呢？一般人的回答是线程安全的，但是这是错误的。如果再打开一个浏览窗口(即使在另一个浏览器中)，但容器仍认为这是同一个会话，这也就造成了多个线程在一个会话中，所以HttpSession中的属性不是线程安全的！这就需要用线程的知识解决了。只需对ServletContext/HttpSession同步即可，千万不能对servlet进行同步，否则就会只有一个线程可以访问servlet，导致效率很低。 只有请求属性和局部变量是线程安全的 ####请求属性与转发如果希望应用的其他组件[Servlet/JSP]接管全部或部分请求，就可以使用请求属性。那么如何让组件的其他部分接管这个请求呢?用RequestDispatcher.举个例子:]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F31%2Fservlet-jsp%2F%E5%88%9D%E8%AF%86Servlet%2F</url>
    <content type="text"><![CDATA[#####一、servlet的一生 当一个请求映射到一个从未被访问过的servlet时，容器还未创建该servlet对象，所以需要创建该对象。容器首先会载入该serlert class,创建servlet对象,调用init()[仅仅一次]，完成初始化工作；随后调用service()方法处理请求；在servlet生命结束前，调用destroy()方法做垃圾清理工作。 三个重要时间点1、init()何时调用: servlet实例创建后，在提供服务之前，要对servlet调用init()2、serrvice()何时调用:在一个客户请求到来后，容器会创建或从线程池获取一个线程，并调用servlet的service()方法。在servlet()中，判断Http方法(get or post),相应调用doGet() or doPost()3、doGet()/doPost()由service()方法调用，在里面处理我们的业务逻辑 通常，一个servlet class只有一个实例，也就是说对同一个servlet的多个请求共用一个servlet实例，相应的多个请求处理线程共用同一个servlet实例。每一个请求到来，创建or从线程池获取一个线程，并调用servlet的service()方法处理请求。 #####二、servlet继承结构API]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F31%2Fservlet-jsp%2F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[#一、ServletConfig有必要事先说明，该参数作用仅在一个servlet中,所以应在内部 ####例子 12345678910web.xml中&lt;servlet&gt; &lt;init-param&gt; &lt;param-name&gt;初始化参数名&lt;/param-name&gt; &lt;param-value&gt;值&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;servlet中getServletConfig.getInitParameter(&quot;初始化参数名&quot;); ####具体使用 因为servlet继承了getServletConfig(),所以在servlet中的任何方法中都调用getServletConfig()来获取ServletConfig的引用 内部原理 容器初始化一个servlet时，会为这个servlet创建一个唯一的ServletConfig。容器从web.xml中读出servlet初始化参数【仅读一次】，并把这些参数交给ServletConfig,然后把SErvletConfig传递给servlet的int()方法。 #二、ServletContextServletContext作用在整个webapp中,所以在内部，在外部 ####例子 1234567891011121314web.xml中&lt;web-app&gt; &lt;context-param&gt; &lt;param-name&gt;初始化参数名&lt;/param-name&gt; &lt;param-value&gt;值&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; .. &lt;/servlet&gt;&lt;/web-app&gt;servlet中getServletContext().getInitParameter(“初始化参数名”) #三、总结 每一个Servlet都有一个ServletConfig每一个WEB应用都有一个ServletContext]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F31%2Fservlet-jsp%2F%E4%BC%9A%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[###会话如何工作 HttpSession对象可以保存跨同一个client多个请求的会话状态 ##容器是如何辨认客户提一点:由于Http协议是无状态的，所以每个请求都来自一个新的client 客户需要一个唯一的会话ID对客户的第一个请求，容器会生成一个唯一的会话ID,并通过响应把它返回给客户。客户再在以后的每一次请求中发回这个会话ID。容器看到ID后，就会找到匹配的会话，并把这个会话与请求关联 #####客户和容器是如何交会话ID信息容器必须要把会话ID作为响应的一部分发给客户；客户也必须把会话ID作为请求的一部分发给容器。1.Cookies实现2.URL重写 ###HttpSession APIObject getAttribute(“attributeNme”)setAttribute(“attributeName”,object)removeAttribute(“attributeNme”)]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F31%2Fservlet-jsp%2FURL%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[XML文件配置 内部名映射到全限定类名内部名映射到公共url名 1234567891011&lt;web-app ...&gt; &lt;servlet&gt; &lt;servlet-name&gt;Internal name 1&lt;/servlet-name&gt; &lt;servlet-class&gt;foo.Servlet1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Internal name 1&lt;/servlet-name&gt; &lt;url-pattern&gt;/Public1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F31%2Fservlet-jsp%2FTomcat%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[#####java JDK下载:http://www.oracle.com/technetwork/java/javase/downloads/index.html 系统变量配置 123456eg: jdkjdk-9.0.1 安装路径:C:\Program Files\Java\jdk-9.0.1JAVA_HOME = C:\Program Files\Java\jdk-9.0.1JRE_HOME = C:\Program Files\Java\jre-9.0.1PATH = .;%JAVA_HOME%\bin;%JRE_HOME%\binCLASSPATH = .;%JAVA_HOME%\lib;%JRE_HOME%\lib注:变量不存在就创建,存在就添加 #####Tomcat免安装版下载:http://tomcat.apache.org/系统变量配置： 1234eg: 解压路径:C:\Program Files\Tomcat8.5TOMCAT_HOME=C:\Program Files\Tomcat8.5\apache-tomcat-8.5.24CATALINA_HOME=%TOMCAT_HOME%CATALINA_BASE=%TOMCAT_HOME% 重要一步:修改bin目录下的startup.bat在首行的位置添加SET JAVA_HOME=JDK的目录SET CATALINA_HOME=前面解压后Tomcat的目录 123eg：SET JAVA_HOME= C:\Program Files\Java\jdk-9.0.1SET CATALINA_HOME=C:\Program Files\Tomcat8.5\apache-tomcat-8.5.24 最后启动:双击startup.bat关闭:双击shutdown.bat 验证成功:启动tomcat,在浏览器中输入地址:http://localhost:8080出现]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F31%2Fservlet-jsp%2Fsevelet%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[####request ######一、Post请求 只需在Servlet或者jsp中写入如下代码就可以把解决从表单中传入的中文乱码问题 1request.setCharacterEncoding(&quot;utf-8&quot;); ######二、Get请求因为请求参数会被附加到地址栏的URL之后，所以不能用上面的处理方法 一种方法就是获取请求参数之后对请求参数值重新编码，也就是先将其转换成字节数组，再将字节数组重新解码成字符串。 1234eg：String str=request.getParameter(&quot;name&quot;);byte[] bytes=str.getBytes(&quot;ISO-8859-1&quot;);String name=new String(bytes,&quot;utf-8&quot;); ####response #####一、Get请求 response.setContentType(“text/html;charset=utf-8”); #####二、Post请求 response.setContentType(“text/html;charset=utf-8”); 指定 HTTP 响应的编码，同时指定了浏览器显示的编码字节流:不要设置编码格式]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F31%2Fservlet-jsp%2Fservlet%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[#####一、简介 123456在服务器端运行的Java程序,主要作用是控制Java Web程序的业务逻辑该程序段主要组成:Init() service() destroy()在服务器中,当servlet的实例只创建一个Init()在首次创建servlet实例是进行调用,初始化相关参数。Destroy()在servlet销毁时,被调用Service() 主要提供请求的处理，它在servlet的生命周期中可以多次被调用 ######service中包含两个方法 12345678910111213141516171819处理Get请求 doGet(HttpServletReqquest request,HttpServletResponse response)处理Post请求 doPost(HttpServletReqquest request,HttpServletResponse response)简要介绍request、responserequest:存储请求的一些信息request.getParameter(&quot;paraName&quot;);//从JSP页面或URL中获取参数值，返回字符串类型request.setAttribute(&quot;name&quot;,variable);//设置一个键值对,通常传递给JSP页面或另外一个servlet。variable可以为任意类型request.getAttribute(&quot;name&quot;);//取出与name相对应的属性值request.getCookies();//获取从浏览器传来的Cookies返回值类型Cookie[] ，通常在JSP页面获取从而预填写相关内容request.getSession()//获取Sessionrequest.getRequestDispatcher(&quot;url&quot;).forward(request, response);//转发，服务器内进行request.getInputStream();//获取输入字节流(没有字符流)注:Session在域上的方法与request差不多,只是Session作用在一次会话的范围内，而request作用在一次请求范围内responseresponse.getOutputStream(); //获取字节输出流response.getWriter(); //获取字节输出流response.addCookie(cookie);//在反应中添加一个cookieresponse.sendRedirect(&quot;url&quot;);//重定向到url #####二、重定向与转发的区别 1234567891、A、浏览器行为 重定向时，浏览器至少会发送两次请求，并且地址栏的URL会改变。 第一次请求:浏览器向服务器发送一个请求，服务器收到请求后，向浏览器发送一个重定向连接，然后浏览器接收到这个连接 第二次请求:浏览器依据连接向服务器再次发送请求,服务器收到请求后向浏览器发送响应，浏览器收到响应后并显示到页面 B、服务器行为 浏览器只请求一次。转发是在服务器内部进行的，浏览器并不知道，它的地址栏是不会变的2、A、转发是可以携带数据的，也就是说在转发servlet之间可以共享数据的（常用request） B、重定向不能携带数据，因为重定向可以到另一个网站3、A、转发只能在本站点内之间 B、重定向可以到任何URL注意: 转发不需要带项目名,重定向需要带项目名 #####三、Cookie简单用法 12345678910111213创建: Cookie cookie = new Cookie(&quot;name&quot;,value);cookie.getName();//获取Namecookie.getValue(&quot;name&quot;);//获取name对应的值Cookie与Session的关系Cookie 存储一个键值对，主要用途识别浏览器端用户的身份和保存一些信息,例如用户名和密码。Session:表示一次回话,可以包含多次请求。原理： 由于Http是无状态的协议，意味着每个请求都是相对独立的，那么服务器就需要一种机制来识别具体用户，所以Session和Cookie油然而生(当然有其他方法来实现这一机制)，服务端要为特定的用户来创建特定的Session，保存在服务器中。而Cookie就是在浏览器和服务器之间来回跑，里面包含Session ID,用来标识特定的用户。当第一次浏览器向服务器发送一个请求时，服务器会为用户创建一个Session，并会向响应中添加一个Cookie，该Cookie中包含Sesson ID。浏览器收到响应后,会把Cookie保存下来，在下次再次向该网站发送请求时，会携带Cookie(其中包含Session ID)，服务器收到请求后，可以依据Cookie中的Session iD来识别特定的用户。 详细资料:http://www.blogjava.net/cheneyfree/archive/2007/05/26/120168.html]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F31%2Fservlet-jsp%2FJSTL%E6%A0%87%E7%AD%BE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在html中起到逻辑控制作用1、设置标签库 1&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 2、&lt;c:set/&gt; 12&lt;c:set var=&quot;name&quot; value=&quot;&quot; scope=&quot;Scope&quot;/&gt;相当于在Scope.setAttribute(&quot;name&quot;,value); 3、&lt;c:if test=””&gt; 123&lt;c:if test=&quot;$&#123;..&#125;&quot;&gt;&lt;/c:if&gt;test的值为true或false 4、&lt;c:choose&gt; &lt;c:when&gt; &lt;c:otherwise&gt; 1234567&lt;c:choose&gt; &lt;c:when test=&quot;&quot;&gt; &lt;/c:when&gt; &lt;c:when test=&quot;&quot;&gt; &lt;c:otherwise&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt; 5、&lt;c:forEach&gt; 123某个域中的遍历集合&lt;c:forEach var = &quot;item&quot; items=&quot;$&#123;Scope.list&#125;&quot;&gt; &lt;!-- item属于list中的元素--&gt;&lt;/c:forEach&gt; 6、&lt;c:url&gt; 12&lt;c:url value =&quot;&quot;/&gt;eg: &lt;a href = &quot;&lt;c:url value=&quot;/index.jsp&quot;/&gt;&quot; /&gt;Index &lt;/a&gt; 7、&lt;c:param&gt; 1&lt;c:param name=&quot;name&quot; value=&quot;value&quot; /&gt; 8、&lt;c:out&gt; 1&lt;c:out vlaue = &quot;显示的内容&quot;&gt;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F31%2Fservlet-jsp%2FJSP%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[JSP 1Java Server Page = html + java脚本 + jsp动态标签 特点 1231、有JSP规范提供,不用编写者实例化2、通过Web容器实现和管理3、所有JSP页面均可使用 九大内置对象 123456789101112131415分类1、输入输出对象:request、response、out2、通信控制对象:pageContext、session、applicaton3、Servlet对象:page、config4、错误处理对象:exception具体a) page : Object 代表当前jsp页面对象 相当于this，几乎不用b) config : ServletConfig 封装的是jsp被变异成servlet以后的配置信息，几乎不用 c) exception Throwable 该对象的使用需要配置 isErrorPage=”true” exception.getMessage()用来获取异常信息d) response HttpServletResponsee) out JspWriter 用来输出内容 out.prinit();f) pageContext PageContext 最小的域对象 只在当前jsp页面生效g) request HttpServletRequest h) session HttpSession i) application ServletContext 语法 1231、&lt;%= %&gt; 在JSP页面输入一个值2、&lt;% %&gt; 可写入Java代码3、可以镶嵌在html中 三大指令&lt;%@ ... %&gt; 123456781、Page2、Include 静态包含 两个JSP页面在编译时结合，形成一个servlet &lt;%@ include file=&quot;path&quot; %&gt;3、Taglib 用来导入第三方库 1、Prefix： 可以任意 2、Uri: 标签库的路径 动作标签 12341、&lt;jsp:include page=&quot;path&quot;/&gt;动态包含2、&lt;jsp:forward path=&quot;path&quot;/&gt;与request的转发相同3、&lt;jsp:param name=&quot;&quot; value=&quot;&quot;/&gt;传递参数 可以通过request.getParameter(&quot;&quot;);来获取该参数]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F31%2Fservlet-jsp%2FJSP%2F</url>
    <content type="text"><![CDATA[####JSP是什么 #####看看容器是如何处理JSP JSP的实质是一个servlet! 容器会创建、初始化这个servlet对象，为每个请求建立一个单独的线程，并调用servlet的service()方法。 #####生命周期 容器会加载这个类，实例化并且初始化，为每一个请求建立一个单独的线程 ，并调用servlet的service方法。 #####那为什么会出现JSP呢？JSP的出现是为了解决前后端分离问题。所以尽量不要在JSP页面进行逻辑处理，而只要让它起显示数据作用。 ####隐式对象 ######浅谈脚本、指令脚本：&lt;% Java代码，有; %&gt;指令： &lt;%@ %&gt;表达式: &lt;= &gt;常用指令：]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F31%2Fservlet-jsp%2FJ2EE%E4%B8%AD%E7%9A%84%E8%AF%B7%E6%B1%82%E5%92%8C%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[转发到JSP 1request.getRequestDispatcher(&quot;myJSP.JSP&quot;).forward(request,response); 转发到Servlet 1request.getRequestDispatcher(&quot;myServlet.do&quot;).forward(request,response); 从定向 1response.sendRedirect(&quot;others&quot;); 可以重定向到本应用的Servlet/JSP，也可以重定向到另外一个应用，但转发只能是在一个应用中。 ##区别 转发client只发出一个请求；重定向发出两次请求，第二次请求是第一次响应给出的 转发是server内部的事情，在servlet内部跳转，也就地址栏不会改变；重定向发生在client端，第二次请求由client发出，所以地址栏会改变 转发一直是client发出的一个resquest,所以转发目的servlet/jsp中可以获取由request.setAttribute(“name”,object);的对象。而重定向是client发出了两次请求，所以是不能在第二次resques中获取到第一次request绑定属性。这也就说明，转发是可以共享数据的，而重定向是不能共享数据的]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F31%2Fservlet-jsp%2FHttpServletRequest-and-HttpServletResponse%2F</url>
    <content type="text"><![CDATA[#API HttpServletRequest and HttpServletResponse两个接口由容器实现，不需要码农实现，码农只需要知道两接口的方法使用。 请求参数的获取getParameter(“parameterName”)返回String;getParameterValues(“parameterName”)返回String[] response:设置响应内容类型response.setContentType(“MIME type”);//必须首先设置Common MIME types:text/html application/pdf video/quicktime application/java image/jpegapplication/jar application/octet-stream application/x-zip获取字符流PrintWriter writer = response.getWriter();writer.println(“some text and html”);获取字节流OutputStream out = response.getOutputStream();out.write(aByteArray);获取到流后，可以像普通I/O一样进行流操作]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F31%2Fservlet-jsp%2FGET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[POST请求和GET请求都可以传递参数。POST请求有body，参数数据放在body中。而GET请求参数数据放在header中,地址栏可以看见参数数据。来个直观的:]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F31%2Fservlet-jsp%2FEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[EL表达式通常用来获取数据，不是设置数据 ####11个内置对象 ######注: 12345678pageContext:该对象的作用主要是用来获取其他对象 比如request$&#123;pageContext.request.contextPath&#125;------&gt;项目名Param: 用来获取请求参数ParamValues:用来获取请求参数(多个请求值的情形)Head:获取请求头的头值Headvalues：对应一个请求头有多个值的情况。InitParam:获取全局初始化参数 ，可以通过ServletContext对象Cookie:获取浏览器发送过来的cookie ####${} 1234567891011获取数据$&#123;attributeName&#125; //查找顺序 pageContext request session application$&#123;pageScope.attributeName&#125;$&#123;requestScope.attributeName&#125;$&#123;sessionScope.attributeName&#125;$&#123;applicationScope.attributeName&#125;$&#123;cookie.name.value&#125;注:当attributeName为某一对象时,attributeName.member==&gt;attributeName.getMember()list,array$&#123;list[index]&#125;$&#123;array[index]&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F31%2Fservlet-jsp%2FCookie%2F</url>
    <content type="text"><![CDATA[可使用cookie在客户和服务器之间交换名/值(String)。服务器创建cookie并发送给客户端，客户再在以后的请求中都发回这个cookie。 API： HttpServletRequest:Cookie[] getCookies() HttpServletResponse void addCookie(Cookie cookie) Cookie Cookie(String name,String value) String getName() String getValue() void setValue(String newValue) void setMaxAge(int expiry) 生命周期单位秒/s 使Cookie销毁cookie.setMaxAge(0); 来个例子： 12345678910111213//在响应中加入Cookie，发给客户Cookie cookie = new Cookie(&quot;userName&quot;,&quot;wangwu&quot;);cookie.setMaxAge(30*60);//生命周期30分钟response.addCoookie(cookie);//将cookie发送给客户从客户请求中获取cookiesString userName = null;Cookie[] cookies = request.getCookies();for (int i = 0;i &lt; cookies.length;i++)&#123; Cookie cookie = cookies[i]; if ((cookie.getName()).equals(&quot;userName&quot;)) userName = cookie.getValue();&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[9--动态SQLr-foreach]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F9---%E5%8A%A8%E6%80%81SQL--foreach%2F</url>
    <content type="text"><![CDATA[foreach需要注意一点的是:collection为set list array时，index为集合的下标, item为元素值collection为map时，index为key,item为valuedao 1List&lt;Student&gt; listStudents(List&lt;Integer&gt; list); mapper 12345678&lt;select id=&quot;listStudents&quot; resultMap=&quot;studentMapper&quot;&gt; select * from `student` where `id` in &lt;foreach collection=&quot;list&quot; item=&quot;value&quot; index=&quot;indexOrKey&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #&#123;value&#125; &lt;/foreach&gt; &lt;/select&gt; test 12345678910111213141516171819202122@Testpublic void test() &#123; SqlSession session = factory.openSession(); try &#123; StudentMapper studentMapper = session.getMapper(StudentMapper.class); List&lt;Integer&gt; listIds = new ArrayList&lt;&gt;(); listIds.add(1000); listIds.add(10001); List&lt;Student&gt; students = studentMapper.listStudents(listIds); if(!students.isEmpty())&#123; for (Student student: students) &#123; System.out.println(student); &#125; &#125;else&#123; System.out.println(&quot;没有查到结果!&quot;); &#125; &#125; finally &#123; session.commit(); session.close(); &#125;&#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[8-动态SQLr-set]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F8---%E5%8A%A8%E6%80%81SQL--set%2F</url>
    <content type="text"><![CDATA[set ifdao 1int updateStudent(Student student); mapper 123456789101112131415&lt;update id=&quot;updateStudent&quot; parameterType=&quot;student&quot;&gt; update `student` &lt;set&gt; &lt;if test=&quot;name != null&quot;&gt; `name` = #&#123;name&#125;, &lt;/if&gt; &lt;if test=&quot;age != null&quot;&gt; `age` = #&#123;age&#125;, &lt;/if&gt; &lt;if test=&quot;gender != null&quot;&gt; `gender` = #&#123;gender,typeHandler=genderTypeHandler&#125; &lt;/if&gt; &lt;/set&gt; where `id` = #&#123;id&#125; &lt;/update&gt; test 12345678910111213141516171819@Testpublic void test() &#123; SqlSession session = factory.openSession(); try &#123; StudentMapper studentMapper = session.getMapper(StudentMapper.class); int id = 10001; String name = &quot;hu&quot;; int age = 18; GenderEnum gender = GenderEnum.getGender(1); Student student = new Student(id,name,age,gender); int affectedRows = studentMapper.updateStudent(student); System.out.println(affectedRows); System.out.println(studentMapper.selectStudentById(id)); &#125; finally &#123; session.commit(); session.close(); &#125;&#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[7--动态SQLr-where]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F7---%E5%8A%A8%E6%80%81SQL--where%2F</url>
    <content type="text"><![CDATA[where ifdao在含有int类型的查询参数，最好设置为Integer,以便接收null值 123List&lt;Student&gt; selectStudents(@Param(&quot;name&quot;) String name, @Param(&quot;age&quot;) Integer age, @Param(&quot;gender&quot;) GenderEnum gender); mapper 1234567891011121314&lt;select id=&quot;selectStudents&quot; resultMap=&quot;studentMapper&quot;&gt; select * from `student` &lt;where&gt; &lt;if test=&quot;name != null&quot;&gt; `name` like concat(&apos;%&apos;,#&#123;name&#125;,&apos;%&apos;) &lt;/if&gt; &lt;if test=&quot;age != null&quot;&gt; and `age` = #&#123;age&#125; &lt;/if&gt; &lt;if test=&quot;gender != null&quot;&gt; and `gender` = #&#123;gender,typeHandler=genderTypeHandler&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; test 1234567891011121314151617181920212223242526272829@Test public void test() &#123; SqlSession session = factory.openSession(); try &#123; StudentMapper studentMapper = session.getMapper(StudentMapper.class);// Student student = new Student(&quot;hu&quot;,19,GenderEnum.getGender(1));// int affectedRows = studentMapper.insertStudent(student); String name = &quot;h&quot;; int age = 20; GenderEnum gender = GenderEnum.getGender(2); List&lt;Student&gt; students = studentMapper.selectStudents(name, age,gender);// List&lt;Student&gt; students = studentMapper.selectStudents(name, age,null);// List&lt;Student&gt; students = studentMapper.selectStudents(name, null,gender);// List&lt;Student&gt; students = studentMapper.selectStudents(name, null,null);// List&lt;Student&gt; students = studentMapper.selectStudents(null, null,null); if(!students.isEmpty())&#123; Iterator&lt;Student&gt; it = students.iterator(); while(it.hasNext())&#123; Student student = it.next(); System.out.println(student); &#125; &#125;else&#123; System.out.println(&quot;没有查到结果&quot;); &#125; &#125; finally &#123; session.commit(); session.close(); &#125; &#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[6--TypeHandler-2]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F6---TypeHandler-2%2F</url>
    <content type="text"><![CDATA[本小节对枚举类型进行转换table 123456create table `student`(`id` int auto_increment primary key,`name` varchar(30) not null,`age` int,`gender` int default 0)auto_increment=10000; enum 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package model;public enum GenderEnum &#123; MALE(&quot;男&quot;,0),FEMALE(&quot;女&quot;,1),UNKNOW(&quot;不知道&quot;,2); private String gender; private int code; GenderEnum(String gender, int code)&#123; this.gender = gender; this.code = code; &#125; public static GenderEnum getGender(String genderName)&#123; for (GenderEnum gender: GenderEnum.values())&#123; if(gender.gender.equalsIgnoreCase(genderName))&#123; return gender; &#125; &#125; return null; &#125; public static GenderEnum getGender(int code)&#123; for (GenderEnum gender: GenderEnum.values())&#123; if(gender.code == code)&#123; return gender; &#125; &#125; return null; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; @Override public String toString() &#123; return &quot;GenderEnum&#123;&quot; + &quot;gender=&apos;&quot; + gender + &apos;\&apos;&apos; + &quot;, code=&quot; + code + &apos;&#125;&apos;; &#125;&#125; model 12345678910111213package model;public class Student &#123; private int id; private String name; private int age; private GenderEnum gender; public Student() &#123; &#125; //getter setter &#125; dao 1234public interface StudentMapper &#123; int insertStudent(Student student); Student selectStudentById(int id);&#125; mapper这里的typeHandler使用了别名 123456789101112131415161718&lt;insert id=&quot;insertStudent&quot; parameterType=&quot;student&quot;&gt; insert into `student`(`name`,`age`,`gender`) values(#&#123;name&#125;,#&#123;age&#125;,#&#123;gender,typeHandler=genderTypeHandler&#125;) &lt;selectKey resultType=&quot;int&quot; keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; order=&quot;AFTER&quot;&gt; select last_insert_id(); &lt;/selectKey&gt; &lt;/insert&gt; &lt;resultMap id=&quot;studentMapper&quot; type=&quot;student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt; &lt;result property=&quot;gender&quot; column=&quot;gender&quot; typeHandler=&quot;genderTypeHandler&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectStudentById&quot; parameterType=&quot;int&quot; resultMap=&quot;studentMapper&quot;&gt; select * from `student` where `id` = #&#123;id&#125; &lt;/select&gt; test 12]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[5--TypeHandler-1]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F5---TypeHandler-1%2F</url>
    <content type="text"><![CDATA[当需要将jdbc类型的数据和Java程序中类型的书数据进行转换时，可以使用TypeHandler来完成转换过程。怎么实现呢?Java类型==》jdbc将Java类型值value1通过某种策略转化为数据库(jdbc)类型值value2，然后将value2设置为SQL参数 :preparedStatement.setType(i,value2);Java类型《== jdbc从resultSet中取出值value2，然后通过某种策略将value2转换为Java类型值value1 table123456create table `student`(`id` int auto_increment primary key,`name` varchar(30) not null,`age` int,`birthday` varchar(30))auto_increment=10000; model123456789101112131415package model;import java.util.Date;public class Student &#123; private int id; private String name; private int age; private Date birthday;//在数据库中对应的类型是varchar(n) public Student() &#123; &#125;//getter和setter略&#125; TypeHandler123456789101112131415161718192021222324252627//表注转换的两种类型@MappedJdbcTypes(&#123;JdbcType.VARCHAR&#125;)//jdbc类型@MappedTypes(&#123;java.util.Date.class&#125;)//程序类型public class MyDateTypeHandler extends BaseTypeHandler&lt;Date&gt; &#123; @Override public void setNonNullParameter(PreparedStatement preparedStatement, int i, Date date, JdbcType jdbcType) throws SQLException &#123; preparedStatement.setString(i,String.valueOf(date.getTime())); &#125; @Override public Date getNullableResult(ResultSet resultSet, int i) throws SQLException &#123; return new Date(resultSet.getLong(i)); &#125; @Override public Date getNullableResult(ResultSet resultSet, String s) throws SQLException &#123; return new Date(resultSet.getLong(s)); &#125; @Override public Date getNullableResult(CallableStatement callableStatement, int i) throws SQLException &#123; return new Date(callableStatement.getLong(i)); &#125;&#125; dao12345678910package dao;import model.Student;public interface StudentMapper &#123; int insertStudent(Student student); Student selectStudentById(int id);&#125; mapper在对应参数处使用typeHandler来转换作为输入参数:#{birthday,typeHandler=dao.MyDateTypeHandler}这里的typeHandler的值不成写成字符串类型作为输出结果:&lt;result property=&quot;birthday&quot; column=&quot;birthday&quot; typeHandler=&quot;dao.MyDateTypeHandler&quot;/&gt; 123456789101112131415161718&lt;insert id=&quot;insertStudent&quot; parameterType=&quot;student&quot;&gt; insert into `student`(`name`,`age`,`birthday`) values(#&#123;name&#125;,#&#123;age&#125;,#&#123;birthday,typeHandler=dao.MyDateTypeHandler&#125;) &lt;selectKey resultType=&quot;int&quot; keyProperty=&quot;id&quot; keyColumn=&quot;id&quot; order=&quot;AFTER&quot;&gt; select last_insert_id() &lt;/selectKey&gt; &lt;/insert&gt; &lt;resultMap id=&quot;studentMapper&quot; type=&quot;student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot; typeHandler=&quot;dao.MyDateTypeHandler&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectStudentById&quot; parameterType=&quot;int&quot; resultMap=&quot;studentMapper&quot;&gt; select * from `student` where `id` = #&#123;id&#125; &lt;/select&gt; test1234567891011121314151617181920212223242526272829public class AppTest &#123; SqlSessionFactory factory = null; @Before public void prepare() throws IOException&#123; InputStream inputStream = Resources.getResourceAsStream(&quot;mybatis.xml&quot;); factory = new SqlSessionFactoryBuilder().build(inputStream); inputStream.close(); &#125; @Test public void test()&#123; SqlSession session = factory.openSession(); try&#123; StudentMapper studentMapper = session.getMapper(StudentMapper.class);// Student student = new Student(&quot;wang&quot;,20,new Date());// int affectedRows = studentMapper.insertStudent(student); int id=10001; Student student = studentMapper.selectStudentById(id); System.out.println(student); &#125;finally&#123; session.commit(); session.close(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[4--一对一]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F4---%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2~%E4%B8%80%E5%AF%B9%E4%B8%80%2F</url>
    <content type="text"><![CDATA[一本书只属于一个人!table 123456789101112create table `student`(`id` int auto_increment primary key,`name` varchar(30) not null,`age` int)auto_increment=10000;create table `book`(`id` int auto_increment primary key,`bookName` varchar(20),`author` varchar(10),`studentID` int references `student`(`id`))auto_increment=10000; model 123456789101112131415161718192021public class Student &#123; private int id; private String name; private int age; public Student()&#123;&#125; //getter setter略&#125;public class Book &#123; private int bookID; private String bookName; private String author; private Student student; public Book() &#123; &#125; //getter setter略&#125; dao 123public interface StudentMapper &#123; Book findBook(int bookID);&#125; mapper.xml方式一：嵌套 12345678910111213141516171819202122&lt;resultMap id=&quot;bookMapper&quot; type=&quot;book&quot;&gt; &lt;id column=&quot;bookID&quot; property=&quot;bookID&quot;/&gt; &lt;result column=&quot;bookName&quot; property=&quot;bookName&quot;/&gt; &lt;result column=&quot;author&quot; property=&quot;author&quot;/&gt; &lt;association property=&quot;student&quot; javaType=&quot;student&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;findBook&quot; resultMap=&quot;bookMapper&quot;&gt; select `student`.`id` `id`,`student`.`name` `name`, `student`.`age` `age`, `book`.`id` `bookID`, `book`.`bookName` `bookName`, `book`.`author` `author` from `student`,`book` where `student`.`id` = `book`.`studentID` and `book`.`id` = #&#123;bookID&#125;;&lt;/select&gt; 方式二:复用resultMapper 123456789101112131415161718192021222324 &lt;select id=&quot;findBook&quot; resultMap=&quot;bookMapper&quot;&gt; select `student`.`id` `id`, `student`.`name` `name`, `student`.`age` `age`, `book`.`id` `bookID`, `book`.`bookName` `bookName`, `book`.`author` `author` from `student`,`book` where `student`.`id` = `book`.`studentID` and `book`.`id` = #&#123;bookID&#125;; &lt;/select&gt;&lt;resultMap id=&quot;studentMapper&quot; type=&quot;student&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt; &lt;/resultMap&gt; &lt;resultMap id=&quot;bookMapper&quot; type=&quot;book&quot;&gt; &lt;id column=&quot;bookID&quot; property=&quot;bookID&quot;/&gt; &lt;result column=&quot;bookName&quot; property=&quot;bookName&quot;/&gt; &lt;result column=&quot;author&quot; property=&quot;author&quot;/&gt; &lt;association property=&quot;student&quot; resultMap=&quot;studentMapper&quot;/&gt; &lt;/resultMap&gt; 综合3、4关联查询两篇文章，总结一下1.明确实体之间的关系，优化范式，构建表2.依据业务，构建model3.编写关联查询语句 首先编写简单的model开始，建议使用resutlMap来映射，因为当SQL复杂时，嵌套很容易出错。然后依据一对一association或一对多collection来创建复杂实体。最后编写关联查询语句，注意返回字段的名称。需要注意两点: resultMap中的column属性必须和数据库返回字段相同 resultMap中的property属性必须和Model的成员属性相同]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[3--关联查询~一对多]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F3---%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2~%E4%B8%80%E5%AF%B9%E5%A4%9A%2F</url>
    <content type="text"><![CDATA[本小节将要介绍一对一、一对多的查询【技术上】。你有可能会问，多对多怎么查，这个问题就不该问！开玩笑的，哈哈。其实在设计表时，一般多对多的关系就已经转化为一对多了。 ###一对多就用一个学生有多本书籍来举例子吧!table 123456789101112create table `student`(`id` int auto_increment primary key,`name` varchar(30) not null,`age` int)auto_increment=10000;create table `book`(`id` int auto_increment primary key,`bookName` varchar(20),`author` varchar(10),`studentID` int references `student`(`id`))auto_increment=10000; model 123456789101112131415161718192021public class Student &#123; private int id; private String name; private int age; private List&lt;Book&gt; books; public Student() &#123;//无参构造函数===&gt;创建对象 &#125;//getter和setter略&#125;public class Book &#123; private int bookID; private String bookName; private String author; public Book() &#123; &#125;&#125;//getter和setter略 dao 123public interface StudentMapper &#123; Student findMyBooks(int id);&#125; mapple.xml方式一，直接嵌套 12345678910111213141516171819202122&lt;select id=&quot;findMyBooks&quot; resultMap=&quot;studentMapper&quot;&gt; select `student`.`id` `id`,`student`.`name` `name`, `student`.`age` `age`, `book`.`id` `bookID`, `book`.`bookName` `bookName`, `book`.`author` `author` from `student`,`book` where `student`.`id` = `book`.`studentID` and `student`.`id` = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id=&quot;studentMapper&quot; type=&quot;student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt; &lt;collection property=&quot;books&quot; ofType=&quot;book&quot;&gt; &lt;id property=&quot;bookID&quot; column=&quot;bookID&quot;/&gt; &lt;result property=&quot;bookName&quot; column=&quot;bookName&quot;/&gt; &lt;result property=&quot;author&quot; column=&quot;author&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 方式二：resultMap复用 123456789101112131415161718192021222324&lt;select id=&quot;findMyBooks&quot; resultMap=&quot;studentMapper&quot;&gt; select `student`.`id` `id`,`student`.`name` `name`, `student`.`age` `age`, `book`.`id` `bookID`, `book`.`bookName` `bookName`, `book`.`author` `author` from `student`,`book` where `student`.`id` = `book`.`studentID` and `student`.`id` = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id=&quot;bookMapper&quot; type=&quot;book&quot;&gt; &lt;id property=&quot;bookID&quot; column=&quot;bookID&quot;/&gt; &lt;result property=&quot;bookName&quot; column=&quot;bookName&quot;/&gt; &lt;result property=&quot;author&quot; column=&quot;author&quot;/&gt;&lt;/resultMap&gt;&lt;resultMap id=&quot;studentMapper&quot; type=&quot;student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt; &lt;collection property=&quot;books&quot; resultMap=&quot;bookMapper&quot;/&gt;&lt;/resultMap&gt; 关联查询必须用无参构造函数来创建对象，如果没有无参构造函数，就会报构造函数参数错误。希望能引起你的警觉。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1--基本CRUD]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F2---%E5%9F%BA%E6%9C%ACCURD%2F</url>
    <content type="text"><![CDATA[dao 123456789101112131415161718package dao;import model.Student;import java.util.List;public interface StudentMapper &#123; List&lt;Student&gt; selectAllStudent(); int insertStudent(Student student); int updateStudent(Student student); int deleteById(int id);&#125;​` mapple.xml 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;dao.StudentMapper&quot;&gt; &lt;select id=&quot;selectAllStudent&quot; resultType=&quot;student&quot;&gt; select * from `student` &lt;/select&gt; &lt;insert id=&quot;insertStudent&quot; parameterType=&quot;student&quot;&gt; insert into `student`(`name`,`age`) values(#&#123;name&#125;,#&#123;age&#125;) &lt;selectKey resultType=&quot;int&quot; keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; order=&quot;AFTER&quot;&gt; select last_insert_id(); &lt;/selectKey&gt; &lt;/insert&gt; &lt;update id=&quot;updateStudent&quot; parameterType=&quot;student&quot;&gt; update `student` set `name` = #&#123;name&#125;,`age` = #&#123;age&#125; where `id` = #&#123;id&#125; &lt;/update&gt; &lt;delete id=&quot;deleteById&quot; parameterType=&quot;int&quot;&gt; delete from `student` where `id` = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import dao.StudentMapper;import model.Student;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Iterator;import java.util.List;public class AppTest &#123; SqlSessionFactory factory = null; @Before public void prepare() throws IOException&#123; InputStream inputStream = Resources.getResourceAsStream(&quot;mybatis.xml&quot;); factory = new SqlSessionFactoryBuilder().build(inputStream); inputStream.close(); &#125; @Test public void test()&#123; SqlSession session= factory.openSession(); try&#123; StudentMapper studentMapper = session.getMapper(StudentMapper.class); List&lt;Student&gt; list = studentMapper.selectAllStudent(); Iterator&lt;Student&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; Student student = iterator.next(); System.out.println(student); &#125; &#125;finally&#123; session.commit(); session.close(); &#125; &#125; @Test public void testInsert()&#123; SqlSession sqlSession = factory.openSession(); try&#123; StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); Student student = new Student(&quot;young&quot;,20); int affectedRows = studentMapper.insertStudent(student); if(affectedRows==1)&#123; System.out.println(&quot;插入成功!&quot;); System.out.println(student);//查看从数据库返回id填充student的id属性 &#125;else&#123; System.out.println(&quot;插入失败!&quot;); &#125; &#125;finally &#123; sqlSession.commit(); sqlSession.close(); &#125; &#125; @Test public void testUpdate()&#123; SqlSession sqlSession = factory.openSession(); try&#123; StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); Student student = new Student(10000,&quot;Tom&quot;,21); int affectedRows = studentMapper.updateStudent(student); if(affectedRows != 0)&#123; System.out.println(&quot;更新成功!&quot;); System.out.println(student); &#125;else&#123; System.out.println(&quot;更新失败&quot;); &#125; &#125;finally &#123; sqlSession.commit(); sqlSession.close(); &#125; &#125; @Test public void testDelete()&#123; SqlSession sqlSession = factory.openSession(); try&#123; StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); int id = 10000; int affectedRows = studentMapper.deleteById(id); if(affectedRows == 1)&#123; System.out.println(&quot;删除成功!&quot;); &#125;else&#123; System.out.println(&quot;删除失败!&quot;); &#125; &#125;finally &#123; sqlSession.commit(); sqlSession.close(); &#125; &#125;&#125; 注意 插入、删除、修改要获取数据库中受影响的记录数，以便验证操作是否成功 插入一条数据最好返回从数据库返回生成的ID来给model的id赋值，以便后续使用 ```]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1--搭建环境]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F1---%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[####一.单独使用Mybaitsjar包测试:junit数据库驱动: mysql-connector-javaMybatis: mybatislog4j: log4j-core log4j-api1.创建db,properties 1234database.driver=com.mysql.jdbc.Driverdatabase.url=jdbc:mysql://localhost:3306/dbName?serverTimezone=UTC database.username=rootdatabase.password=*** 2.配置mybatis.xml 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--要注意该文件的节点顺序，否则会报错--&gt; &lt;!--引入属性文件--&gt; &lt;properties resource=&quot;db.properties&quot;/&gt; &lt;settings&gt; &lt;!--配置日志,固定写法--&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J2&quot;&gt;&lt;/setting&gt; &lt;/settings&gt; &lt;!--给实体取别名--&gt; &lt;typeAliases&gt; &lt;package name=&quot;dao&quot;/&gt; &lt;package name=&quot;model&quot;/&gt; &lt;/typeAliases&gt; &lt;!--数据源配置--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;database.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;database.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;database.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;database.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入mapple文件--&gt; &lt;mappers &gt; &lt;mapper resource=&quot;mapple/studentMapple.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 3.日志 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt; &lt;Appenders&gt; &lt;Console name=&quot;console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt; &lt;/Console&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt; &lt;logger name=&quot;org.springframework&quot; level=&quot;INFO&quot;&gt;&lt;/logger&gt; &lt;logger name=&quot;org.mybatis&quot; level=&quot;INFO&quot;&gt;&lt;/logger&gt; &lt;root level=&quot;debug&quot;&gt; &lt;appender-ref ref=&quot;console&quot;/&gt; &lt;/root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 4.dao和model 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package dao;import model.Student;import java.util.List;public interface StudentMapper &#123; List&lt;Student&gt; selectAllStudent();&#125;package model;public class Student &#123; private int id; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; + &quot;, age=&quot; + age + &apos;&#125;&apos;; &#125;&#125; 5.mapple 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;dao.StudentMapper&quot;&gt; &lt;select id=&quot;selectAllStudent&quot; resultType=&quot;student&quot;&gt; select * from `student` &lt;/select&gt;&lt;/mapper&gt; 6.测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344import dao.StudentMapper;import model.Student;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Iterator;import java.util.List;public class AppTest &#123; SqlSessionFactory factory = null; @Before public void prepare() throws IOException&#123; InputStream inputStream = Resources.getResourceAsStream(&quot;mybatis.xml&quot;); factory = new SqlSessionFactoryBuilder().build(inputStream); inputStream.close(); &#125; @Test public void test()&#123; SqlSession session= factory.openSession(); try&#123; StudentMapper studentMapper = session.getMapper(StudentMapper.class); List&lt;Student&gt; list = studentMapper.selectAllStudent(); Iterator&lt;Student&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; Student student = iterator.next(); System.out.println(student); &#125; &#125;finally&#123; session.commit(); session.close(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
</search>
