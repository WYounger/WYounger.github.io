<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[3.SpringBoot自定义事件与监听]]></title>
    <url>%2F2020%2F05%2F29%2FSpringBoot%2F3.SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E4%B8%8E%E7%9B%91%E5%90%AC%2F</url>
    <content type="text"><![CDATA[1.事件-监听模型主要构成元素，事件、事件发布者、事件监听者 事件监听者向事件发布者订阅事件。当事件发生时，事件发布者会通知事件监听者，然后事件监听者可以做出相应的处理。 在Spring使用这一事件模型，主要是为了降低各个业务逻辑之间的耦合性。 2.实例1.定义事件通常是继承ApplicationEven来定义自定义事件 1234567891011121314151617181920/** * 定义事件 */@Datapublic class StuRegisterEvent extends ApplicationEvent &#123; /** * 监听器感兴趣的信息 */ private Student stu; /** * 事件构造器。 * @param source 事件发出者。第一个参数必须有，首先调用父类构造器 * @param stu 具体事件信息 */ public StuRegisterEvent(Object source,Student stu) &#123; super(source); this.stu = stu; &#125;&#125; 2.定义事件监听器总共有三种方法来实现对事件的监听。 使用@EventListener注解 实现ApplicationListener&lt;E&gt;接口 实现SmartApplicationListener接口.它继承了ApplicationListener,并继承了``Ordered`接口.因此可以定义监听器触发的先后顺序 123456789101112131415161718192021222324/** * 使用注解定义监听器 */@Slf4j@Componentpublic class StuRegisterEventListener &#123; /** * @param stuRegisterEvent 事件 */ @EventListener public void handleStuRegisterEvent(StuRegisterEvent stuRegisterEvent)&#123; log.info("监听器1"); log.info(stuRegisterEvent.toString()); &#125; /** * @param stuRegisterEvent 事件 */ @EventListener public void handleStuRegisterEvent1(StuRegisterEvent stuRegisterEvent)&#123; log.info("监听器1-1"); log.info(stuRegisterEvent.toString()); &#125;&#125; 123456789101112/** * 直接实现ApplicationListener&lt;T&gt;接口 */@Component@Slf4jpublic class StuRegisterEventListener2 implements ApplicationListener&lt;StuRegisterEvent&gt; &#123; @Override public void onApplicationEvent(StuRegisterEvent stuRegisterEvent) &#123; log.info("监听器2"); log.info(stuRegisterEvent.toString()); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Slf4j@Componentpublic class StudentRegisterEventListener3 implements SmartApplicationListener &#123; /** * @param sourceType 事件源类型 * @return */ @Override public boolean supportsSourceType(Class&lt;?&gt; sourceType) &#123; return true; &#125; /** * @param aClass 事件的类型 * @return */ @Override public boolean supportsEventType(Class&lt;? extends ApplicationEvent&gt; aClass) &#123; return aClass == StuRegisterEvent.class; &#125; /** * 处理事件 supportsSourceType()和supportEventType都返回true，才会触发监听事件 * @param applicationEvent 事件 */ @Override public void onApplicationEvent(ApplicationEvent applicationEvent) &#123; StuRegisterEvent stuRegisterEvent = (StuRegisterEvent) applicationEvent; log.info("监听器0"); log.info(stuRegisterEvent.toString()); &#125; /** * 触发监听事件的顺序。 * @return 当一个事件发生，有多个监听器监听，可以规定这个几个监听器触发的顺序 * @return 返回值越小，越早触发 */ @Override public int getOrder() &#123; return 0; &#125;&#125; 使用建议: 当同一事件的多个监听器触发时间没有顺序,使用注解形式更加简单,并且在各个监听器类可以同时定义 多个监听方法 有触发顺序要求的,就只能使用实现SmartApplicationListener接口的方式 3.发布事件使用ApplicationEventPublisher来发布事件 12345678910111213141516@Service@Slf4jpublic class StuServiceImpl implements StuService &#123; /** * 注入事件发布者 */ @Autowired ApplicationEventPublisher publisher; @Override public void registerStu(Student stu) &#123; log.info("注册一个学生"); //发布事件. 通过事件源和事件信息构建事件 publisher.publishEvent(new StuRegisterEvent(this,stu)); &#125;&#125; 4.异步]]></content>
      <categories>
        <category>springboot 基础</category>
      </categories>
      <tags>
        <tag>spirngboot 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基本命令]]></title>
    <url>%2F2020%2F03%2F02%2Fmysql%2FMySQL%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[启动,关闭,重启12345678service mysql startservice mysql stopservice mysql restart# 若以上命令报错,使用如下命令:systemctl start mysqld.servicesystemctl stop mysqld,servicesystemctl restart mysqld.service 基本命令 连接数据库 1234567# 远程连接mysql -hHost -PPort -uUserName -pPwd# 本地连接mysql -uUserName -pPwd# 注意: 属性和值之间可以有无空格 显示数据库基本信息 1234567891011# 显示所有数据库show databases# 选择一个库use dbName# 显示一个库中所有表show tables# 显示一个表的字段信息desc tableName 用户相关命令 查看用户 1234# 切换到mysql数据库use mysql;# 从user表查找 用户名和主机select user,host from user; 创建用户并授权 12345678910111213141516171819# 创建用户create user 'userName'@'host' identified by 'pwd';# host: 远程主机IP,localhost '%': 表示所有IP# 授权grant 权限 on *.* to 'userName'@'host';# 权限： ALL,ALTER,CREATE,DROP,SELECT,UPDATE,DELETE# *.* 任意库任意表#刷新权限flush privileges# 修改密码alter user 'userName'@'host' identified by 'newPWd';#修改当前用户的密码alter user user() identifed by 'newPwd';# 删除用户drop user 'userName'@'host';# 通常userName后面的"@'host'"被省略,表示host取%，所有IP SQL操作在命令行中写SQL语句，和我通常写的SQL一致。下面讲一下索引的创建和删除、事务 索引123456789-- 显示所有索引show index from tableName;-- 创建索引alter table tableName add index indexName (col1,col2,..,coln);-- 还有其他方式创建索引-- 删除索引drop index indexName on tableName 事务123456789101112131415161718192021222324252627-- 显示当前隔离级别-- globalselect @@global.transaction_isolation;-- 本次sessionselect @@transaction_isolation;-- 以上两条命令针对mysql 8-- 设置隔离级别set 范围 transaction isolation level 级别-- 范围: -- global 针对所有以后session-- session 仅限于本次会话-- 级别: Read uncommitted | Read committed | Repeatable Read| Serializable-- 事务自动提交set autocommit = 0; -- 设置手动提交set autocommit = 1; -- 设置自动提交# 开启事务begin; -- 或者start transaction; #提交commit;-- 回滚rollback; 参考Mysql常用命令总结]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8-时间类API]]></title>
    <url>%2F2020%2F02%2F16%2Fjava8%2F8-%E6%97%B6%E9%97%B4%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[LocalDate12345678910111213141516171819202122232425262728293031323334353637/** * LocalDate localDate = LocalDate.now(); * LocalDate localDate2 = LocalDate.of(2015, 12, 31); */LocalDate date = LocalDate.now();date.toString();//2020-02-16LocalDate date1 = LocalDate.of(2020, 1, 1);date1.toString();//2020-01-01/** * getYear() * getMonth() * getDayOfMonth() * getDayOfWeek() * getDayOfYear() */date.getYear(); //2020date.getMonth(); //FEBRUARYdate.getDayOfMonth();//16date.getDayOfWeek();//SUNDAYdate.getDayOfYear();//47/** * plusDays() * plusWeeks() * plusMonths() * plusYears() * minusDays() * minusWeeks() * minusMonths() * minusYears() */LocalDate localDate = date.plusYears(2);//date的值不变localDate.toString(); //2022-02-16 LocalTime12345678910111213141516171819202122232425262728293031323334353637/** * LocalTime localTime = LocalTime.now(); * LocalTime localTime2 = LocalTime.of(21, 30, 59, 11001); */LocalTime time = LocalTime.now();time.toString();//10:08:30.006339900LocalTime time1 = LocalTime.of(10,15,50,20);time1.toString();//10:15:50.000000020/** * getHour() * getMinute() * getSecond() * getNano() */time1.getHour();//10time1.getMinute();//15time1.getSecond();//50time1.getNano();//20/** * plusHours() * plusMinutes() * plusSeconds() * plusNanos() * minusHours() * minusMinutes() * minusSeconds() * minusNanos() * compareTo() */LocalTime localTime = time1.plusHours(2);//原始值不变localTime.toString();// 12:15:50.000000020time.compareTo(time1);//1:time &gt; time1 -1:time &lt; time1 LocalDateTime12345678910111213141516171819202122232425262728293031323334353637383940LocalDateTime dateTime = LocalDateTime.now();dateTime.toString();//2020-02-16T10:31:18.944879100LocalDateTime dateTime1 = LocalDateTime.of(2020,1,1,1,1,1,1);dateTime1.toString();//2020-01-01T01:01:01.000000001/** * getYear() * getMonth() * getDayOfMonth() * getDayOfWeek() * getDayOfYear() * getHour() * getMinute() * getSecond() * getNano() *//** * plusYears() * plusMonths() * plusDays() * plusHours() * plusMinutes() * plusSeconds() * plusNanos() * minusYears() * minusMonths() * minusDays() * minusHours() * minusMinutes() * minusSeconds() * minusNanos() * isBefore() * isAfter() */LocalDateTime dateTime2 = dateTime1.plusYears(2);dateTime2.toString();//2022-01-01T01:01:01.000000001dateTime.isBefore(dateTime1);//falsedateTime2.isAfter(dateTime1); //true DateTimeFormatter123456789101112131415161718192021//LocalDateTime -&gt; StringDateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");LocalDateTime dateTime = LocalDateTime.now();dateTime.format(formatter); //String: 2020-02-16 10:53:39// String -&gt; LocalDateTime//标准格式LocalDateTime parse = LocalDateTime.parse("2020-01-01T01:01:01");parse.toString();//2020-01-01T01:01:01//当string不符合标准字符串格式，需要传递该string的格式LocalDateTime parse1 = LocalDateTime.parse("2020-01-01 01:01:01",formatter);parse1.toString();//2020-01-01T01:01:01//LocalDate相同LocalDate date = LocalDate.now();DateTimeFormatter formatter1 = DateTimeFormatter.ofPattern("yyyy/MM/dd");formatter1.format(date);//String: 2020/02/16//标准格式2020-01-01，非标准格式，需传递格式化器LocalDate parse2 = LocalDate.parse("2020/01/01", formatter1);parse2.toString(); // 2020-01-01 参考Java Date Time Tutorial]]></content>
      <categories>
        <category>java8</category>
      </categories>
      <tags>
        <tag>basic-java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7.optional取代null]]></title>
    <url>%2F2020%2F02%2F01%2Fjava8%2F7-optional%E5%8F%96%E4%BB%A3null%2F</url>
    <content type="text"><![CDATA[1.Optional由来从数据库查数据和上游获取对象经常回遇到NPE(NullPointerExcepiton),本来null就是编程鼻祖们代表”不存在的值”一种的简洁表示。 1234567891011121314151617181920212223242526@Data@AllArgsConstructor@NoArgsConstructorclass Person&#123; private Car car;&#125;@Data@AllArgsConstructor@NoArgsConstructorclass Car&#123; private Insurance insurance;&#125;@Data@AllArgsConstructor@NoArgsConstructorclass Insurance&#123; private String name;&#125;static String getInsuranceName(Person person)&#123; //person，car,insurance都可能为空,NPE在这三处都有可能抛出 return person.getCar().getInsurance().getName(); //传统解决方案 //三重判断，为空返回默认值或null //代码省略&#125; null带来的问题 错误之源 多层嵌套预防，代码膨胀 使用Optional 123456789101112131415161718@Data@AllArgsConstructor@NoArgsConstructorclass Person&#123; private Optional&lt;Car&gt; car;&#125;@Data@AllArgsConstructor@NoArgsConstructorclass Car&#123; private Optional&lt;Insurance&gt; insurance;&#125;@Data@AllArgsConstructor@NoArgsConstructorclass Insurance&#123; private String name;&#125; 语义清晰，Person可能有车也可能没车，车有保险也可能没有保险，保险是必须有名称的. 2.Optional使用对象创建Optional的对象都是用静态工厂方法创建的,总共有三种语义的Optional的对象. 123456//创建一个包含空值的optionalOptional&lt;String&gt; optionalEmpty = Optional.empty(); //创建一个包含非空值的optionalOptional&lt;String&gt; optional = Optional.of("hello");//创建一个课包含空值的optionalOptional&lt;String&gt; optionalOfNullable= Optional.ofNullable(null); 原理见附录源码,很容易看懂 对象使用1234567891011121314Optional&lt;String&gt; optional = Optional.ofNullable("hello world");//如果optional保存的是不是空值，则返回该值;否则，返回抛出异常。所以慎用optional.get();//hello world//如果optional保存的是不是空值，则返回该值;否则，返回后面的返回值optional.orElseGet(()-&gt;"empty string");//hello worldoptional.orElse("empty string");//hello world//如果optional保存的是不是空值,则执行actionoptional.ifPresent(e -&gt; &#123; System.out.println(e);&#125;);//和stream类似，数据映射转换。Optional&lt;String[]&gt; strings = optional.map(e -&gt; e.split(" "));//Optional&lt;T&gt; -&gt; Stream&lt;T&gt;Stream&lt;String[]&gt; stream = strings.stream(); //stream.count() = 1 用上面的改造后例子单独讲一下flatMap 1234567891011121314151617Optional&lt;Person&gt; optionalPerson = Optional.of( new Person(Optional.of(new Car(Optional.of(new Insurance("***保险"))))));/** * 1. Person::getCar -&gt; Optional&lt;Car&gt; * 2. optionalPerson.map(Person::getCar) -&gt; Optional&lt;Optional&lt;Car&gt;&gt; * 3. Optional&lt;Optional&lt;Car&gt;&gt; 显然不能调用 map(Car::getInsurance) * 4. 只有Optional&lt;Car&gt;.map(Car::getInsurance)才行，所以多套了一层Optional * 5. 为了去掉多层Optional(本例只用一层),得使用flatMap */// Optional&lt;String&gt; optionalStr = optionalPerson.map(Person::getCar).map(Car::getInsurance).map(Insurance::getName);String insuranceName = optionalPerson. flatMap(Person::getCar). flatMap(Car::getInsurance). map(Insurance::getName). orElse("null value");System.out.println(insuranceName); //***保险 flatMap小结 Stream中,将多条Stream汇聚成一条Stream Optional中,将Optional&lt;Optional&gt;的多层结构去壳直至Optional 3.附录-源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426/* * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. */package java.util;import java.util.function.Consumer;import java.util.function.Function;import java.util.function.Predicate;import java.util.function.Supplier;import java.util.stream.Stream;/** * A container object which may or may not contain a non-&#123;@code null&#125; value. * If a value is present, &#123;@code isPresent()&#125; returns &#123;@code true&#125; and * &#123;@code get()&#125; returns the value. * * &lt;p&gt;Additional methods that depend on the presence or absence of a contained * value are provided, such as &#123;@link #orElse(Object) orElse()&#125; * (returns a default value if no value is present) and * &#123;@link #ifPresent(Consumer) ifPresent()&#125; (performs an * action if a value is present). * * &lt;p&gt;This is a &lt;a href="../lang/doc-files/ValueBased.html"&gt;value-based&lt;/a&gt; * class; use of identity-sensitive operations (including reference equality * (&#123;@code ==&#125;), identity hash code, or synchronization) on instances of * &#123;@code Optional&#125; may have unpredictable results and should be avoided. * * @apiNote * &#123;@code Optional&#125; is primarily intended for use as a method return type where * there is a clear need to represent "no result," and where using &#123;@code null&#125; * is likely to cause errors. A variable whose type is &#123;@code Optional&#125; should * never itself be &#123;@code null&#125;; it should always point to an &#123;@code Optional&#125; * instance. * * @param &lt;T&gt; the type of value * @since 1.8 */public final class Optional&lt;T&gt; &#123; /** * Common instance for &#123;@code empty()&#125;. */ private static final Optional&lt;?&gt; EMPTY = new Optional&lt;&gt;(); /** * If non-null, the value; if null, indicates no value is present */ private final T value; /** * Constructs an empty instance. * * @implNote Generally only one empty instance, &#123;@link Optional#EMPTY&#125;, * should exist per VM. */ private Optional() &#123; this.value = null; &#125; /** * Returns an empty &#123;@code Optional&#125; instance. No value is present for this * &#123;@code Optional&#125;. * * @apiNote * Though it may be tempting to do so, avoid testing if an object is empty * by comparing with &#123;@code ==&#125; against instances returned by * &#123;@code Optional.empty()&#125;. There is no guarantee that it is a singleton. * Instead, use &#123;@link #isPresent()&#125;. * * @param &lt;T&gt; The type of the non-existent value * @return an empty &#123;@code Optional&#125; */ public static&lt;T&gt; Optional&lt;T&gt; empty() &#123; @SuppressWarnings("unchecked") Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY; return t; &#125; /** * Constructs an instance with the described value. * * @param value the non-&#123;@code null&#125; value to describe * @throws NullPointerException if value is &#123;@code null&#125; */ private Optional(T value) &#123; this.value = Objects.requireNonNull(value); &#125; /** * Returns an &#123;@code Optional&#125; describing the given non-&#123;@code null&#125; * value. * * @param value the value to describe, which must be non-&#123;@code null&#125; * @param &lt;T&gt; the type of the value * @return an &#123;@code Optional&#125; with the value present * @throws NullPointerException if value is &#123;@code null&#125; */ public static &lt;T&gt; Optional&lt;T&gt; of(T value) &#123; return new Optional&lt;&gt;(value); &#125; /** * Returns an &#123;@code Optional&#125; describing the given value, if * non-&#123;@code null&#125;, otherwise returns an empty &#123;@code Optional&#125;. * * @param value the possibly-&#123;@code null&#125; value to describe * @param &lt;T&gt; the type of the value * @return an &#123;@code Optional&#125; with a present value if the specified value * is non-&#123;@code null&#125;, otherwise an empty &#123;@code Optional&#125; */ public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) &#123; return value == null ? empty() : of(value); &#125; /** * If a value is present, returns the value, otherwise throws * &#123;@code NoSuchElementException&#125;. * * @apiNote * The methods &#123;@link #orElse(Object) orElse&#125; and * &#123;@link #orElseGet(Supplier) orElseGet&#125; * are generally preferable to this method, as they return a substitute * value if the value is absent, instead of throwing an exception. * * @return the non-&#123;@code null&#125; value described by this &#123;@code Optional&#125; * @throws NoSuchElementException if no value is present * @see Optional#isPresent() */ public T get() &#123; if (value == null) &#123; throw new NoSuchElementException("No value present"); &#125; return value; &#125; /** * If a value is present, returns &#123;@code true&#125;, otherwise &#123;@code false&#125;. * * @return &#123;@code true&#125; if a value is present, otherwise &#123;@code false&#125; */ public boolean isPresent() &#123; return value != null; &#125; /** * If a value is present, performs the given action with the value, * otherwise does nothing. * * @param action the action to be performed, if a value is present * @throws NullPointerException if value is present and the given action is * &#123;@code null&#125; */ public void ifPresent(Consumer&lt;? super T&gt; action) &#123; if (value != null) &#123; action.accept(value); &#125; &#125; /** * If a value is present, performs the given action with the value, * otherwise performs the given empty-based action. * * @param action the action to be performed, if a value is present * @param emptyAction the empty-based action to be performed, if no value is * present * @throws NullPointerException if a value is present and the given action * is &#123;@code null&#125;, or no value is present and the given empty-based * action is &#123;@code null&#125;. * @since 9 */ public void ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction) &#123; if (value != null) &#123; action.accept(value); &#125; else &#123; emptyAction.run(); &#125; &#125; /** * If a value is present, and the value matches the given predicate, * returns an &#123;@code Optional&#125; describing the value, otherwise returns an * empty &#123;@code Optional&#125;. * * @param predicate the predicate to apply to a value, if present * @return an &#123;@code Optional&#125; describing the value of this * &#123;@code Optional&#125;, if a value is present and the value matches the * given predicate, otherwise an empty &#123;@code Optional&#125; * @throws NullPointerException if the predicate is &#123;@code null&#125; */ public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) &#123; Objects.requireNonNull(predicate); if (!isPresent()) &#123; return this; &#125; else &#123; return predicate.test(value) ? this : empty(); &#125; &#125; /** * If a value is present, returns an &#123;@code Optional&#125; describing (as if by * &#123;@link #ofNullable&#125;) the result of applying the given mapping function to * the value, otherwise returns an empty &#123;@code Optional&#125;. * * &lt;p&gt;If the mapping function returns a &#123;@code null&#125; result then this method * returns an empty &#123;@code Optional&#125;. * * @apiNote * This method supports post-processing on &#123;@code Optional&#125; values, without * the need to explicitly check for a return status. For example, the * following code traverses a stream of URIs, selects one that has not * yet been processed, and creates a path from that URI, returning * an &#123;@code Optional&lt;Path&gt;&#125;: * * &lt;pre&gt;&#123;@code * Optional&lt;Path&gt; p = * uris.stream().filter(uri -&gt; !isProcessedYet(uri)) * .findFirst() * .map(Paths::get); * &#125;&lt;/pre&gt; * * Here, &#123;@code findFirst&#125; returns an &#123;@code Optional&lt;URI&gt;&#125;, and then * &#123;@code map&#125; returns an &#123;@code Optional&lt;Path&gt;&#125; for the desired * URI if one exists. * * @param mapper the mapping function to apply to a value, if present * @param &lt;U&gt; The type of the value returned from the mapping function * @return an &#123;@code Optional&#125; describing the result of applying a mapping * function to the value of this &#123;@code Optional&#125;, if a value is * present, otherwise an empty &#123;@code Optional&#125; * @throws NullPointerException if the mapping function is &#123;@code null&#125; */ public &lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) &#123; Objects.requireNonNull(mapper); if (!isPresent()) &#123; return empty(); &#125; else &#123; return Optional.ofNullable(mapper.apply(value)); &#125; &#125; /** * If a value is present, returns the result of applying the given * &#123;@code Optional&#125;-bearing mapping function to the value, otherwise returns * an empty &#123;@code Optional&#125;. * * &lt;p&gt;This method is similar to &#123;@link #map(Function)&#125;, but the mapping * function is one whose result is already an &#123;@code Optional&#125;, and if * invoked, &#123;@code flatMap&#125; does not wrap it within an additional * &#123;@code Optional&#125;. * * @param &lt;U&gt; The type of value of the &#123;@code Optional&#125; returned by the * mapping function * @param mapper the mapping function to apply to a value, if present * @return the result of applying an &#123;@code Optional&#125;-bearing mapping * function to the value of this &#123;@code Optional&#125;, if a value is * present, otherwise an empty &#123;@code Optional&#125; * @throws NullPointerException if the mapping function is &#123;@code null&#125; or * returns a &#123;@code null&#125; result */ public &lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, ? extends Optional&lt;? extends U&gt;&gt; mapper) &#123; Objects.requireNonNull(mapper); if (!isPresent()) &#123; return empty(); &#125; else &#123; @SuppressWarnings("unchecked") Optional&lt;U&gt; r = (Optional&lt;U&gt;) mapper.apply(value); return Objects.requireNonNull(r); &#125; &#125; /** * If a value is present, returns an &#123;@code Optional&#125; describing the value, * otherwise returns an &#123;@code Optional&#125; produced by the supplying function. * * @param supplier the supplying function that produces an &#123;@code Optional&#125; * to be returned * @return returns an &#123;@code Optional&#125; describing the value of this * &#123;@code Optional&#125;, if a value is present, otherwise an * &#123;@code Optional&#125; produced by the supplying function. * @throws NullPointerException if the supplying function is &#123;@code null&#125; or * produces a &#123;@code null&#125; result * @since 9 */ public Optional&lt;T&gt; or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier) &#123; Objects.requireNonNull(supplier); if (isPresent()) &#123; return this; &#125; else &#123; @SuppressWarnings("unchecked") Optional&lt;T&gt; r = (Optional&lt;T&gt;) supplier.get(); return Objects.requireNonNull(r); &#125; &#125; /** * If a value is present, returns a sequential &#123;@link Stream&#125; containing * only that value, otherwise returns an empty &#123;@code Stream&#125;. * * @apiNote * This method can be used to transform a &#123;@code Stream&#125; of optional * elements to a &#123;@code Stream&#125; of present value elements: * &lt;pre&gt;&#123;@code * Stream&lt;Optional&lt;T&gt;&gt; os = .. * Stream&lt;T&gt; s = os.flatMap(Optional::stream) * &#125;&lt;/pre&gt; * * @return the optional value as a &#123;@code Stream&#125; * @since 9 */ public Stream&lt;T&gt; stream() &#123; if (!isPresent()) &#123; return Stream.empty(); &#125; else &#123; return Stream.of(value); &#125; &#125; /** * If a value is present, returns the value, otherwise returns * &#123;@code other&#125;. * * @param other the value to be returned, if no value is present. * May be &#123;@code null&#125;. * @return the value, if present, otherwise &#123;@code other&#125; */ public T orElse(T other) &#123; return value != null ? value : other; &#125; /** * If a value is present, returns the value, otherwise returns the result * produced by the supplying function. * * @param supplier the supplying function that produces a value to be returned * @return the value, if present, otherwise the result produced by the * supplying function * @throws NullPointerException if no value is present and the supplying * function is &#123;@code null&#125; */ public T orElseGet(Supplier&lt;? extends T&gt; supplier) &#123; return value != null ? value : supplier.get(); &#125; /** * If a value is present, returns the value, otherwise throws an exception * produced by the exception supplying function. * * @apiNote * A method reference to the exception constructor with an empty argument * list can be used as the supplier. For example, * &#123;@code IllegalStateException::new&#125; * * @param &lt;X&gt; Type of the exception to be thrown * @param exceptionSupplier the supplying function that produces an * exception to be thrown * @return the value, if present * @throws X if no value is present * @throws NullPointerException if no value is present and the exception * supplying function is &#123;@code null&#125; */ public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X &#123; if (value != null) &#123; return value; &#125; else &#123; throw exceptionSupplier.get(); &#125; &#125; /** * Indicates whether some other object is "equal to" this &#123;@code Optional&#125;. * The other object is considered equal if: * &lt;ul&gt; * &lt;li&gt;it is also an &#123;@code Optional&#125; and; * &lt;li&gt;both instances have no value present or; * &lt;li&gt;the present values are "equal to" each other via &#123;@code equals()&#125;. * &lt;/ul&gt; * * @param obj an object to be tested for equality * @return &#123;@code true&#125; if the other object is "equal to" this object * otherwise &#123;@code false&#125; */ @Override public boolean equals(Object obj) &#123; if (this == obj) &#123; return true; &#125; if (!(obj instanceof Optional)) &#123; return false; &#125; Optional&lt;?&gt; other = (Optional&lt;?&gt;) obj; return Objects.equals(value, other.value); &#125; /** * Returns the hash code of the value, if present, otherwise &#123;@code 0&#125; * (zero) if no value is present. * * @return hash code value of the present value or &#123;@code 0&#125; if no value is * present */ @Override public int hashCode() &#123; return Objects.hashCode(value); &#125; /** * Returns a non-empty string representation of this &#123;@code Optional&#125; * suitable for debugging. The exact presentation format is unspecified and * may vary between implementations and versions. * * @implSpec * If a value is present the result must include its string representation * in the result. Empty and present &#123;@code Optional&#125;s must be unambiguously * differentiable. * * @return the string representation of this instance */ @Override public String toString() &#123; return value != null ? String.format("Optional[%s]", value) : "Optional.empty"; &#125;&#125;]]></content>
      <categories>
        <category>java8</category>
      </categories>
      <tags>
        <tag>basic-java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.默认方法]]></title>
    <url>%2F2020%2F02%2F01%2Fjava8%2F6-%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.默认方法由来当一个接口需要添加新的功能(方法)，则其实现类必须要实现新的方法，这会带来很多的问题。为了能使用新的功能和兼容性，这时，就可以在接口中，添加默认方法完成新的功能，其实现类不会该改动任何代码。 2.使用1.基本使用使用default声明默认方法 1234567891011121314151617181920212223242526@Testpublic void test()&#123; B b = new B(); b.f1(); //f1 b.f2(); //default f2&#125;interface A&#123; void f1(); default void f2()&#123; System.out.println("default f2"); &#125;&#125;class B implements A&#123; @Override public void f1() &#123; System.out.println("f1"); &#125;// @Override// public void f2() &#123;// System.out.println("new f2");// &#125;&#125; 2.重写接口的实现类可以重写默认方法，当调用该方法时，会调用重写之后的方法 3.冲突12345678910111213141516171819interface A&#123; default void hello()&#123; System.out.println("interface A: hello"); &#125;&#125;interface B extends A&#123; default void hello()&#123; System.out.println("interface B: hello"); &#125;&#125;class C implements A,B&#123;&#125; @Test public void test() &#123; C c= new C(); c.hello(); //interface B: hello &#125; 12345678910111213interface A&#123; default void hello()&#123; System.out.println("interface A: hello"); &#125;&#125;interface B extends A&#123; default void hello()&#123; System.out.println("interface B: hello"); &#125;&#125;class C implements A,B&#123;&#125; //无法编译 12345678910111213141516171819interface A&#123; default void hello()&#123; System.out.println("interface A: hello"); &#125;&#125;class B&#123; public void hello()&#123; System.out.println("interface B: hello"); &#125;&#125;class C extends B implements A&#123;&#125; @Test public void test() &#123; C c= new C(); c.hello();//interface B: hello &#125; 总结一下 类或父类中显示声明的方法，其优先级高于所有默认方法。如第三个例子 如果第一条无法判断，方法名又无法区别，则选择提供最具体实现的默认方法的接口。例如第一个例子。 最后冲突无法解决，就只能在类中覆盖该默认方法，显示指定使用接口的中的默认方法。如第二个例子 3.抽象接口与抽象类的区别 一个类可以实现多个接口，但只能继承一个抽象类 抽象类可以有实例变量保状态，而接口只能通过static final保存状态 4.总结接口默认方法提供了接口向后兼容性的一种解决方案，也提供了一种行为继承的一种方案。]]></content>
      <categories>
        <category>java8</category>
      </categories>
      <tags>
        <tag>basic-java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.stream基本用法]]></title>
    <url>%2F2020%2F02%2F01%2Fjava8%2F5-stream%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.删选和切片直接看例子进行讲解 12345678List&lt;Dish&gt; collect = menu .stream() .filter(Dish::isCaloriesOver500)//传入一个谓词 .distinct()//元素所属类必须实现equals方法,才能删选各异元素 .limit(2)//取前多少个元素 .skip(1)//与limit互补，跳过前多少个元素 .collect(Collectors.toList()); collect.forEach(System.out::println); 2.映射和转换类型相似，将一个但是映射创建的全新的值，不会影响原数据。 1234567891011121314//mapList&lt;String&gt; collect = menu.stream() .map(Dish::getName).collect(Collectors.toList()); collect.forEach(System.out::println);//flatMapString[] arr = &#123;"hello","world"&#125;; //得到h,e,l,o,w,r,dStream&lt;String&gt; stream = Arrays.stream(arr);// Stream&lt;String[]&gt; -&gt;Stream&lt;String&gt;stream.map(word -&gt; word.split("")). // Stream&lt;String[]&gt; flatMap(Arrays::stream). // Arrays::stream -&gt; Stream&lt;String&gt; + flatMap -&gt; Stream&lt;String&gt; distinct(). collect(Collectors.toList()); 注意的是latMap,将多个同类型的流合并为一个同类型流。 3.规约lambda反复结合每一个元素，直至流里面只剩一个元素 12345678910111213141516171819202122// 1 + 2 + ... + 5int[] numbers = &#123;1,2,3,4,5&#125;;int sum = Arrays.stream(numbers).reduce(0, (a,b) -&gt; a + b);//或sum = Arrays.stream(numbers).reduce((a,b) -&gt; a + b).getAsInt();//或sum = Arrays.stream(numbers).reduce(Integer::sum).getAsInt();System.out.println(sum);/* int reduce(int identity, IntBinaryOperator op);int reduce(IntBinaryOperator op);@FunctionalInterfacepublic interface IntBinaryOperator &#123; int applyAsInt(int left, int right);&#125;*/int max = Arrays.stream(numbers).reduce((a,b) -&gt; a &lt; b ? b : a).getAsInt();int min = Arrays.stream(numbers).reduce((a,b) -&gt; a &lt; b ? a : b).getAsInt();//方法引用描述int max = Arrays.stream(numbers).reduce(Integer::max).getAsInt();int min = Arrays.stream(numbers).reduce(Integer::min).getAsInt(); 浅析执行求sum过程， 步骤 操作 stream 0 1，2，3，4，5 1 1+2=3 1,2出stream,3入stream 3, 3，4，5 2 3 +3 = 6 3,3出stream，6入stream 6,4,5 3 6 + 4 = 10 6,4出stream，10入stream 10，5 4 10 + 5 = 15 10,5出stream，15入stream,计算结束 15]]></content>
      <categories>
        <category>java8</category>
      </categories>
      <tags>
        <tag>basic-java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.Stream基本概念]]></title>
    <url>%2F2020%2F02%2F01%2Fjava8%2F4-stream%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[首先了解以下流的概念 从支持数据处理操作的源生成的元素序列 流的特性的如下: 元素序列。就像和集合一样，区别在与集合强调数据的存储，而流强调数据的计算 源。流需要源，通常来自集合和数组 数据处理操作。filter,map,reduce,find,match,sort,limit 流水线。很多流操作会返回流，所以可以进行流水线操作 内部迭代。不像迭代器的显示迭代元素，流的迭代操作在背后进行 例子 123456789101112131415161718192021222324252627class Dish &#123; private final String name; private final boolean vegetarian; private final int calories; private final Type type; public enum Type &#123;MEAT, FISH, OTHER&#125; //constructor,getter,setter,toString...&#125;//数据源List&lt;Dish&gt; menu = Arrays.asList( new Dish("pork", false, 800, Dish.Type.MEAT), new Dish("beef", false, 700, Dish.Type.MEAT), new Dish("chicken", false, 400, Dish.Type.MEAT), new Dish("french fries", true, 530, Dish.Type.OTHER), new Dish("rice", true, 350, Dish.Type.OTHER), new Dish("season fruit", true, 120, Dish.Type.OTHER), new Dish("pizza", true, 550, Dish.Type.OTHER), new Dish("prawns", false, 300, Dish.Type.FISH), new Dish("salmon", false, 450, Dish.Type.FISH));List&lt;String&gt; list = menu .stream() //集合可以生成stream .filter( dish -&gt; dish.getCalories() &gt; 500) //1 .map(Dish::getName) //2 .sorted(String::compareToIgnoreCase) //3 .limit(2) //4 .collect(Collectors.toList()); //5 1,2,3,4属于流的中间操作(返回stream的操作)，5属于终端操作 常见的中间操作 操作 操作对象 函数描述符 filter Predicate T -&gt; boolean map Function&lt;T,R&gt; T -&gt; R limit sorted Comparator (T,T) -&gt; int distinct 常见的终端操作 操作 描述 forEach Consumer&lt;? super T&gt; count 返回流中的元素个数 collect 把流归约成一个集合,如List,Map]]></content>
      <categories>
        <category>java8</category>
      </categories>
      <tags>
        <tag>basic-java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.方法引用]]></title>
    <url>%2F2020%2F02%2F01%2Fjava8%2F3-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[方法引用是运用现有函数对lambda表达式的一种简化。基本思想是:如果一个lambda表达式只是直接调用这个方法，那最好还是用名称来调用它，而不是描述如何调用它。 实例 1234567891011//lambda: (E e) -&gt; System.out.println(e)//方法引用: System.out::printlnlist.forEach(System.out::println);//Iterable中的默认方法default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125; &#125; 如何构建方法引用 指向静态方法的方法引用 12345678/** * (args) -&gt; ClassName.staticMethod(args); * ClassName::staticMethod */ Function&lt;String,Integer&gt; function = (String str) -&gt; Integer.parseInt(str); Function&lt;String,Integer&gt; fc = Integer::valueOf; System.out.println(function.apply("1").getClass()); System.out.println(fc.apply("1").getClass()); 指向任意类型实例方法的方法引用 123//ClassName::instanceMethod//eg:String::lenth 指向现有对象的实例方法 123//obj::instanceMethod//eg:stu::getName 实例 12345List&lt;String&gt; list = Arrays.asList("a","A","C","b");//(arg0,arg1) -&gt; arg0.instannceMethod(arg1)list.sort(String::compareToIgnoreCase);//(arg) -&gt; System.out.print(arg)list.forEach(System.out::println);]]></content>
      <categories>
        <category>java8</category>
      </categories>
      <tags>
        <tag>basic-java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.java8常用函数式接口]]></title>
    <url>%2F2020%2F02%2F01%2Fjava8%2F2-java8%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[Predicate判断一个对象是否满足一定的条件 123456789101112131415161718192021222324@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; boolean test(T t);&#125; @Test public void test()&#123; List&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student("young1",17)); list.add(new Student("young2",19)); Predicate&lt;Student&gt; predicate = (Student stu) -&gt; stu.age &gt; 18; //传入Predicate filter(list,predicate).forEach(System.out::println); &#125; public static List&lt;Student&gt; filter(List&lt;Student&gt; students,Predicate&lt;Student&gt; predicate)&#123; List&lt;Student&gt; result = new ArrayList&lt;&gt;(10); for(Student stu : students)&#123; if(predicate.test(stu))&#123; result.add(stu); &#125; &#125; return result; &#125; Consumer仅仅执行一个关于对象的动作 12345678910111213141516171819@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; void accept(T t);&#125; @Test public void test()&#123; List&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student("young1",17)); list.add(new Student("young2",19)); Consumer&lt;Student&gt; consumer = (Student stu) -&gt; System.out.println(stu); forEach(list,consumer); &#125; public static &lt;E&gt; void forEach(List&lt;E&gt; list, Consumer&lt;E&gt; consumer)&#123; for (E e : list)&#123; consumer.accept(e); &#125; &#125; Function1234567891011121314151617181920@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; R apply(T t);&#125;@Test public void test()&#123; List&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student("young1",17)); list.add(new Student("young2",19)); map(list,(Student stu) -&gt; stu.name).forEach(System.out::println); &#125; public static &lt;T,R&gt; List&lt;R&gt; map(List&lt;T&gt; list,Function&lt;T,R&gt; function)&#123; List&lt;R&gt; result = new ArrayList&lt;&gt;(); for (T t : list)&#123; result.add(function.apply(t)); &#125; return result; &#125;]]></content>
      <categories>
        <category>java8</category>
      </categories>
      <tags>
        <tag>basic-java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.lambda表达式]]></title>
    <url>%2F2020%2F02%2F01%2Fjava8%2F1-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.看个例子匿名内部类实现一个线程启动 1234567Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("匿名内部类"); &#125;&#125;);thread.start(); 匿名内部类实现了Runnale接口,重写run方法. 看看lambda的简洁性 1234Thread thread2 = new Thread(() -&gt; &#123; System.out.println("lambda表达式");&#125;);thread2.start(); 显而易见,lambda表达式代码更加简洁清晰 2.lambda表达式的一般式12345678910(Type1 var1,Type2 var2,...) -&gt; expresssion(Type1 var1,Type2 var2,...) -&gt; &#123; expressions&#125; /** * Type1 var1,Type2 var2,...:待重写方法的参数列表 * 方法体: 一条语句或多条语句(用&#123;&#125;括起来) * 返回值: 待重写方法的返回值类型 */ 实例 1234567891011121314151617181920 @Test public void test()&#123; A a1 = (int var1,String var2) -&gt; var1 + var2; //单条语句不用显示的通过return语句来返回值 A a2 = (int var1,String var2) -&gt; &#123; //模拟多条语句 String str = String.valueOf(var1); return str + var2; &#125;; System.out.println(a1.dosomething(1,"2")); System.out.println(a2.dosomething(1,"2")); &#125;&#125;@FunctionalInterfaceinterface A&#123; String dosomething(int var1,String var2);&#125; 这个实例解释了lambda表达式的实质: 一个实现接口的对象。 3.使用场景先解释一个概念,函数式接口: 只包含一个抽象方法，默认方法不是抽象方法 。lambda就是用在实现这样的接口上。 举几个JDK中常见的函数式接口。可以使用@FunctionalInterface进行标注,提供便便宜检查，当被标注的接口不满足函数式接口，就会报错， 1234567891011121314@FunctionalInterfacepublic interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2);&#125;@FunctionalInterfacepublic interface Runnable &#123; public abstract void run();&#125;@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; 实例 123456789101112131415161718192021 @Test public void test()&#123; List&lt;Student&gt; students = new ArrayList&lt;&gt;(10); int LENGTH = 10; Random random = new Random(1L); for(int i = 1; i &lt;= LENGTH; i++)&#123; students.add(new Student("young"+i,random.nextInt(100))); &#125; //使用Lambda表达式实现Comparator接口 Collections.sort(students,(Student s1,Student s2) -&gt; s1.getGrade() - s2.getGrade());// Collections.sort(students, Comparator.comparingInt(Student::getGrade)); students.forEach(System.out::println); &#125;&#125;class Student&#123; private String name; private int grade; //getter setter toString...&#125;]]></content>
      <categories>
        <category>java8</category>
      </categories>
      <tags>
        <tag>basic-java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis事务]]></title>
    <url>%2F2019%2F12%2F01%2Fredis%2F4.redis%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[redis事务简介123multi #开启事务do somethingexec #执行事务 传统RDBMS,例如MySQL，以begin指令来开始事务，并执行接下来的指令，然后可以commit或rollback对数据库的修改。而redis使用multi标识事务开始，接下来的命令都会入队(命令尚未被执行)，当执行到exec，redis会在不受其他干扰下，取出并执行队列中的命令。 watch命令redis使用乐观锁来解决数据不一致问题。具体使用如下, 123456789watch keydo some prepared thingif (!condition) unwatch keymultido somethingif (!condition) discardexec 执行watch key之后一直到exec执行之前，如果key有任何修改，那么在执行exec时，事务执行会失败。 unwatch和discard两者都使用在redis事物中，区别在于使用的时机不同: unwatch: 在执行watch之后和multi之前，取消watch discard: 在执行multi之后和exec之前，取消watch，并清空已经入队的命令]]></content>
      <categories>
        <category>redis基础</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>非关系型数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis实际运用]]></title>
    <url>%2F2019%2F12%2F01%2Fredis%2Fredis%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[下面redis的运用，主要把它当成缓存使用 1.记录用户登陆信息由于http是无状态的，为了保存和校验用户身份信息，传统做法是，是将大部分信息保存在session中，当有大量会话接入，会消耗服务器很多资源。你也许会说，session只保存用户id，其他身份相关数据当要用到时，才从关系型数据库取出，但是这会增大数据库的负载，并且速度也不是很快。所以，将这些数据存入redis中是一个不错的选择。 因此，有以下常用实例, 记录和验证用户登陆信息 记录用户的购物车 2.缓存业务数据 使用中间件，缓存页面 缓存数据库中的数据]]></content>
      <categories>
        <category>redis基础</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>非关系型数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis主从复制]]></title>
    <url>%2F2019%2F11%2F30%2Fredis%2F3.redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一主多从，主服务器负责处理写请求，从服务负责处理读请求。主服务器是可读、可写的，从服务是只读的。当主服务器数据更新后，实时同步到从服务器。 从节点基本配置如下 123456789101112# +------------------+ +---------------+# | Master | ---&gt; | Replica |# | (receive writes) | | (exact copy) |# +------------------+ +---------------+# 主服务器ip和portreplicaof &lt;masterip&gt; &lt;masterport&gt;# 主服务器密码masterauth &lt;master-password&gt;# 当从服务器与主服务器失去连接，从服务器是否继续接收客户端请求replica-serve-stale-data yes# 从服务器是否只可读replica-read-only yes 也可以通过命令方法实现 12slaveof host ip #是该服务变为host ip的从服务器slaveof no one # 解除主从关系 通过命令info replication查看节点情况 具体复制步骤 步骤 主服务器操作 从服务器操作 1 等待命令进入 连接主服务器，发送sync命令 2 开始执行BGSAVE，并使用缓冲区记录BGSAVE之后执行的所有命令 从服务依据配置是否继续使用原有数据(如果有)处理请求 3 BGSAVE执行完毕，向从服务器发送快照文件，并在发送期间，继续使用缓冲区记录被执行的写命令 丢弃原来所有数据，开始载入主服务发送过来的快照文件 4 快照文件发送完毕，开始向从服务器发送存储在缓冲区中的写命令 完成对快照文件的解析操作，像往常一样接收命令请求 5 缓冲区存储的写命令发送完毕；从现在开始，每执行一个写命令，就向从服务器发送相同写命令 执行主服务器发来的所有存储在缓冲区的写命令；并从现在开始接收并执行主服务器发送过来的写命令]]></content>
      <categories>
        <category>redis基础</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>非关系型数据库</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F11%2F29%2Feffective-java%2F5.%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[49.检查参数的有效性大多数方法和构造器对于传递进来的参数都会有某些限制，应该在文档中清楚描述出来，并在方法体的开头检查这些参数，及时处理不符合的参数，防止错误蔓延。 50.必要时进行保护性拷贝 当一个外部对象传入本类内部数据结构中，应该考虑当外部对象的状态发生变化时，是否会对内部数据数据结构产生影响 当返回给客户端一个对象时，当该对象在外部发生状态改变，是否影响本类内部数据结构 51.谨慎设计方法签名 谨慎选择方法名 避免过长的参数 对于参数类型，优先使用接口而不是类 对于boolean, 要优先使用两个元素的枚举类型 52.慎用重载]]></content>
  </entry>
  <entry>
    <title><![CDATA[redis持久化选项]]></title>
    <url>%2F2019%2F11%2F26%2Fredis%2F2.redis%E6%8C%81%E4%B9%85%E5%8C%96%E9%80%89%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[Redis提供了两种不同的持久化方法将数据存储到硬盘里。一种方法是快照，另一种是AOF 快照: 将某一时刻的所有数据都写入到硬盘中。 AOF: 只追加文件(append-only-file)，会在执行写命令时，将被执行的写命令复制到硬盘中。 这两种方法可以同时使用，也可以只使用一种方法。当redis服务停止后，当再次重启时，redis会从快照文件或AOF文件读取数据来恢复数据。 1.快照持久化创建快照的几种方法: 客户端可以向redis服务发送BGSAVE命令。redis会fork一个子进程来将快照写入硬盘，而父进程会继续处理命令请求 客户端还可以向redis服务发送SAVE命令。redis会在创建完快照之前是不会处理其他命令请求 redis.conf设置save选项。例如，save 10 100,从最近一次创建快照后，10秒内有100次写入，则会自动触发BGSAVE命令。同时可以有多个save选项，当任一条件满足，都会触发BGSAVE命令 当redis接收到shutdown命令时，执行SAVE，阻塞所有客户端，当SAVE命令执行完后，关闭服务器 当主从复制时，从服务器向主服务器发送一个SYNC命令，可能会激发主服务执行BGSAVE命令 当系统奔溃后，将丢失最近一次生成快照之后更改所有的数据。 2.AOF持久化简单来说就是，将被执行的写命令追加到AOF文件末尾，记录数据变化。 1234appendonly yes #开启AOF持久化# appendfsync always #将每个写命令同步到硬盘，这种方法会严重降低redis速度appendfsync everysec #每秒钟执行一次命令同步# appendfsync no #让操作系统来决定合适进行同步，不推荐 always可以将数据丢失降低到最小，但会对硬盘大量写入，降低redis性能。为了兼顾数据安全性和写入性能，可以考虑使用ererysec,这样最多只会丢失一秒钟内产生的数据。 随着redis不断处理命令请求，同步写命令会使AOF文件会越来越大，那么就要用到重写/压缩AOF文件 可以使用BGREWRITEAOF命令来redis服务重写AOF文件。原理和BGSAVE一样，父进程会fork一个子进程来执行AOF重写。也可以使用redis.conf来配置，当条件满足时，自动执行BGREWRITEAOF命令 123auto-aof-rewrite-percentage 100 auto-aof-rewrite-min-size 64mb# 当AOF文件大小比上一次重写之后的大100%并且现在AOF文件大小大于64MB会自动触发BGREWRITE命令 参考资料: Redis 实战]]></content>
      <categories>
        <category>redis基础</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>非关系型数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.泛型]]></title>
    <url>%2F2019%2F11%2F07%2Feffective-java%2F4.%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[26.请不要使用原生态类型泛型是在1.5引入的，使用它可以有两点优势: 向集合插入不正确的类型的时，可以在编译时就抛出错误，而不是在运行时才抛出异常，即有类型检查。 从集合检索元素时，编译器帮我们做隐式转换，而不需要我们显示强转，既有隐式转换。 标题中的提到的原生态类型是不带任何实际类型的泛型名称，例如List&lt;E&gt;的原生态类型是List。原生态类型缺乏类型安全性，而继续使用仅仅是为了兼容性。 123456789101112131415//定义一个原生类型的列表，允许插入任何类型的数据List list = new ArrayList();//误插入String和Integer两种不同类型的数据list.add("123");list.add(123);//编译通过，运行时取出强转报错Integer i = (Integer) list.get(0);//定义泛型列表List&lt;String&gt; list = new ArrayList&lt;&gt;(10);list.add("123");//编译类型检查，直接报错list.add(123)；//隐式转换String str = list.get(0); 而原生类型其实也有几处适用的地方: 必须在类文字中使用原生类型 1List.class String[].class int.class都是合法的，而List&lt;String.class&gt;和List&lt;?&gt;.class则不合法 在使用instanceof 123456789public void test(Collection&lt;E&gt; collection)&#123; if(collection instanceof Set)&#123;//此处使用原生类型 Set&lt;?&gt; set = (Set&lt;?&gt;) collection;//可以强转 Iterator&lt;?&gt; it = set.iterator(); while (it.hasNext())&#123; System.out.println(it.next()); &#125; &#125; &#125; 27.消除非受检的警告在使用泛型的代码中，很容易出现警告，不要忽略他们。每一条警告都可能在运行时抛出ClassCaseException异常，要尽最大努力消除他们。如果无法消除，但能确定引起警告的代码是类型的安全的，就可以在尽可能小的范围内使用@SuppersssWarnings(&quot;unchecked&quot;)注解禁止该警告。 28.列表由于数组数组具有协变性，而集合没有 1234567//Father[] 依旧是 Son1[] 的父类Father[] sons = new Son1[1];//'运行时'抛出异常ArrayStoreExceptionsons[0] = new Son2();//List&lt;Father&gt; 不是 ArrayList&lt;Son1&gt;的父类List&lt;Father&gt; list = new ArrayList&lt;Son1&gt;(); 以上很容易看出，由于数组的协变性，很容易随意存入元素，然后再运行时抛出异常。 再举个例子 123456789101112131415class A&lt;E&gt;&#123; private E[] arr; public A(Collection&lt;E&gt; collection)&#123; //这里有unchecked cast 警告 arr = (E[]) collection.toArray(); &#125;&#125;class A&lt;E&gt;&#123; private List&lt;E&gt; list; public A(Collection&lt;E&gt; collection)&#123; //无任何警告 list = new ArrayList&lt;&gt;(collection); &#125;&#125; 只想说明一点，数组和泛型不能很好的混合使用。如果在混合使用时，出现异常，应该立马尝试将数组换成列表。 29.优先使用泛型直接看实例，忽略下标范围检查 12345678910111213141516class Stack&#123; public Object[] elements; private int size = 0; private final int DEFAULT_SIZE = 10; public Stack()&#123; elements = new Object[DEFAULT_SIZE]; &#125; public void push(Object e)&#123; this.elements[size++] = e; &#125; public Object pop()&#123; return elements[--size]; &#125;&#125; 方案一 123456789101112131415161718class Stack&lt;E&gt;&#123; public E[] elements; private int size = 0; private final int DEFAULT_SIZE = 10; @SuppressWarnings("unchecked") public Stack()&#123; //创建时强转 elements = (E[]) new Object[DEFAULT_SIZE]; &#125; public void push(E e)&#123; this.elements[size++] = e; &#125; public E pop()&#123; return elements[--size]; &#125;&#125; 方案二 1234567891011121314151617class Stack&lt;E&gt;&#123; public Object[] elements; private int size = 0; private final int DEFAULT_SIZE = 10; public Stack()&#123; elements = new Object[DEFAULT_SIZE]; &#125; public void push(Object e)&#123; this.elements[size++] = e; &#125; @SuppressWarnings("unchecked") public E pop()&#123; return (E) elements[--size]; &#125;&#125; 原始代码没有使用泛型，容易造成类型安全问题。方案一和方案二都是用了泛型了，更加安全些。 方案一要确保elements中的元素都是通过push存储进去的，不能将elements暴露在外，否则容易造成类型全问题 优先使用方案一，方案一只需强转一次，而方案二在每次pop元素时都要进行强转。 30.优先考虑泛型方法静态工具方法尤其适合泛型化，例如Collections中的排序和查找算法 1234567891011121314151617181920212223242526public class MyTest &#123; @Test public void test() &#123; Set&lt;String&gt; set1 = Set.of("1","2"); Set&lt;String&gt; set2 = Set.of("2","3"); Set&lt;String&gt; resultUnion = A.union(set1,set2); System.out.println(resultUnion); Set&lt;String&gt; resultIntersection = A.intersection(set1,set2); System.out.println(resultIntersection); &#125;&#125;class A&#123; //计算两个集合的并集 public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;E&gt; set1,Set&lt;E&gt; set2)&#123; Set&lt;E&gt; result = new HashSet&lt;&gt;(set1); result.addAll(set2); return result; &#125; //计算两个集合的交集 public static &lt;E&gt; Set&lt;E&gt; intersection(Set&lt;E&gt; set1,Set&lt;E&gt; set2)&#123; Set&lt;E&gt; result = new HashSet&lt;&gt;(set1); result.retainAll(set2); return result; &#125;&#125; 下面递归泛型的例子 12345678910111213141516171819202122public class MyTest &#123; @Test public void test() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(3); list.add("1"); list.add("3"); list.add("2"); System.out.println(A.max(list)); &#125;&#125;class A&#123; public static &lt;E extends Comparable&lt;E&gt;&gt; E max(Collection&lt;E&gt; collection)&#123; E max = null; for (E e : collection)&#123; if(max == null || e.compareTo(max) &gt; 0)&#123; max = e; &#125; &#125; return max; &#125;&#125; 31.利用有限制通配符类提升API的灵活性A是B的子类，但List&lt;A&gt;不是List&lt;B&gt;的子类。可以使用?提高灵活性 1234567891011121314151617181920212223public class MyTest &#123; @Test public void test() &#123; Stack&lt;A&gt; stack = new Stack&lt;&gt;(); stack.pushAll(new ArrayList&lt;B&gt;()); &#125;&#125;class A &#123;&#125;class B extends A&#123;&#125;class Stack&lt;E&gt;&#123; List&lt;E&gt; list; public Stack()&#123; list = new ArrayList&lt;&gt;(); &#125; //E的任何子类的集合都可以传入 public void pushAll(Collection&lt;? extends E&gt; src)&#123; for (E e : src)&#123; list.add(e); &#125; &#125;&#125; 12345678910111213141516171819202122public class MyTest &#123; @Test public void test() &#123; Stack&lt;B&gt; stack = new Stack&lt;&gt;(); stack.pushAll(new ArrayList&lt;A&gt;()); &#125;&#125;class A &#123;&#125;class B extends A&#123;&#125;class Stack&lt;E&gt;&#123; List&lt;E&gt; list; public Stack()&#123; list = new ArrayList&lt;&gt;(); &#125; //可以传入任何E的父类的集合 public void pushAll(Collection&lt;? super E&gt; dst)&#123; for (E e : list)&#123; dst.add(e); &#125; &#125;&#125; 总结一下，当外来元素要进来，就是用? extents E, 因为传入的元素必须是E以及子类，才能被E接收。 当内部元素要出去，就使用? super E，因为E要出去，必须要使用E以及父类才能接收。 32.谨慎并用泛型和可变参数略 33.优先考虑类型安全的异构容器略 参考文献 [Effective Java中文版（第3版）]]]></content>
      <categories>
        <category>basic-java</category>
      </categories>
      <tags>
        <tag>basic-java</tag>
        <tag>effective-java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.接口和类]]></title>
    <url>%2F2019%2F11%2F07%2Feffective-java%2F3.%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[本章节放在最后学习!]]></content>
      <categories>
        <category>basic-java</category>
      </categories>
      <tags>
        <tag>basic-java</tag>
        <tag>effective-java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.对于所有对象通用的方法]]></title>
    <url>%2F2019%2F10%2F30%2Feffective-java%2F2.%E5%AF%B9%E4%BA%8E%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%83%BD%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[10.覆盖equals时请遵守通用约定当一个类要具有“逻辑相等”，且父类没有覆盖equals方法，就需要覆盖equals. 等价需要遵循以下性质: 自反性 对称性 传递性 一致性(当比较的信息没改变时，多次调用equals方法，结果相同) 实际覆盖步骤 使用==操作符检查”参数是否为这个对象的引用” 使用instanceof操作符检查”参数是否为正确的类型” 把参数转换为正确的类型 对于该类中每个“关键域”，检查参数中的域是否与该对象中对应的域相匹配 实例，JDK中String的equals方法 12345678910111213public boolean equals(Object anObject) &#123;//注意参数类型是Object类型，否则不是覆盖 if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String aString = (String)anObject; if (coder() == aString.coder()) &#123; return isLatin1() ? StringLatin1.equals(value, aString.value) : StringUTF16.equals(value, aString.value); &#125; &#125; return false; &#125; 11.覆盖equals时总要覆盖hashCode约定: 在程序运行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对同一个对象多次的调用，hashCode方法必须始终返回同一个值。简单说就是，比较的属性没变，那么hashCode就保持不变 如果两个对象根据equals(Object)方法比较是相等的，那么这两个对象的hashCode()返回值应该是一致的 如果两个对象根据equals(Obejct)方法比较是不想等的，那么这两对象的hashCode()返回值不一定要不相等 总结以下2，3两条，相等的两个对象，hashCode一定要相等。而不相等的两个对象，hashCode可以相等也可以不相等，当然，为了减少散列表的发生冲突的概率，应尽量保持不相等。 HashMap和HashSet中比较对象对象相等，hashCode至关重要。 至于怎样重写hashCode方法，最好使用专业工具来生成。 12.始终要覆盖toString大多数情况下使用toString方法是为了调试，覆盖它应该养成一种编码习惯 13.谨慎覆盖clone这里只谈深拷贝，不谈浅拷贝。 拷贝一个对象最好使用拷贝构造器或者是静态工厂方法。下面举个例子 12345678910111213141516171819202122232425262728293031323334class B&#123; public String param; public B(String param)&#123; this.param = param; &#125; //拷贝构造器，产生一个新对象 public B(B b)&#123; this.param = b.param; &#125; //工厂方法，产生一个新对象 public static B newInstance(B b)&#123; return new B(b.param); &#125;&#125;class A&#123; public B b; public String param; public A(B b,String param)&#123; this.b = b; this.param = param; &#125; //拷贝构造器 public A(A a)&#123; //对于引用类型必须产生一个新的对象，才能完成深拷贝。而基本数据类型直接赋值即可 //调用B的工厂方法 this.b = B.newInstance(a.b); this.param = a.param; &#125; //工厂方法 public static A newInstance(A a)&#123; return new A(B.newInstance(a.b),a.param); &#125;&#125; 当编写拷贝代码时，遇到引用类型，一定要注意是否创建了新的对象。 14.考虑实现Comparable接口首先看两个例子 1.实现Comparable接口 12345678910111213141516171819202122232425262728293031323334353637383940public class MyTest &#123; @Test public void test() &#123; Person[] persons = new Person[10]; for (int i = persons.length - 1; i &gt;= 0; i--)&#123; persons[i] = new Person(i); &#125; Arrays.sort(persons); for (Person item : persons)&#123; System.out.println(item); &#125; &#125;&#125;//实现Comparable&lt;T&gt;接口class Person implements Comparable&lt;Person&gt;&#123; private int age; //复写compareTo(T o)方法 @Override public int compareTo(Person o) &#123; //升序 return Integer.compare(this.age,o.getAge()); &#125; public Person(int age)&#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; @Override public String toString() &#123; return "Person&#123;" + "age=" + age + '&#125;'; &#125;&#125; 2.使用比较器 123456789101112131415161718192021222324252627282930313233343536373839public class MyTest &#123; @Test public void test() &#123; Person[] persons = new Person[10]; for (int i = persons.length - 1; i &gt;= 0; i--)&#123; persons[i] = new Person(i); &#125; //传入泛型比较器 Arrays.sort(persons, new Comparator&lt;Person&gt;() &#123; @Override public int compare(Person o1, Person o2) &#123; //升序 return Integer.compare(o1.getAge(),o2.getAge()); &#125; &#125;); for (Person item : persons)&#123; System.out.println(item); &#125; &#125;&#125;class Person&#123; private int age; public Person(int age)&#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; @Override public String toString() &#123; return "Person&#123;" + "age=" + age + '&#125;'; &#125;&#125; 需要注意注意一点的是，在Java7中，基本数据类型的包装类型都给出了静态的compare方法，所以最好在对基本数据类型作比较的时候，推荐使用它。如下，Integer中compare方法的实现， 123public static int compare(int x, int y) &#123; return (x &lt; y) ? -1 : ((x == y) ? 0 : 1);&#125;参考文献 Effective Java中文版（第3版）]]></content>
      <categories>
        <category>basic-java</category>
      </categories>
      <tags>
        <tag>basic-java</tag>
        <tag>effective-java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.创建和销毁对象]]></title>
    <url>%2F2019%2F10%2F25%2Feffective-java%2F1-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[1. 用静态工厂方法代替构造器创建一个的实例，通常做法是提供一个公有的构造器。还有一种是提供一个静态工厂方法，他是一个返回类的实例的静态方法。 下面列出使用静态工厂方法的优点 有名称 不必在每次调用他们的时候都创建一个新的对象 可以返回类型的任何子类型的对象 所返回的对象的类可以随着每次调用而发生变化，这取决于该方法的参数值 方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在 2.遇到多个构造器函数参数时要考虑使用构建器当一个类的构造器有许多参数，并且有些参数是可选的，首先想到可以通过几个构造函数之间逐级调用来创建对象，但这种方法让客户端编写难以理解。不妨使用构建器来创建对象。见下面一个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class MyTest &#123; @Test public void test()&#123; A a = new A.Builder("requiredParam1","requiredParam2").optionalParam3("optionalParam3").build(); System.out.println(a); &#125;&#125;class A &#123; private final String requiredParam1; private final String requiredParam2; private final String optionalParam3; private final String optionalParam4; private final String optionalParam5; //静态内部类来充当构建器 public static class Builder&#123; //成员变量和构建的目标对象基本保持一致，对可选值进行初始化 private final String requiredParam1; private final String requiredParam2; private String optionalParam3 = "default"; private String optionalParam4 = "default"; private String optionalParam5 = "default"; //构建器的构造函数传入必填参数 public Builder(String requiredParam1,String requiredParam2)&#123; this.requiredParam1 = requiredParam1; this.requiredParam2 = requiredParam2; &#125; //使用链式API来设置可选值 public Builder optionalParam3(String optionalParam3)&#123; this.optionalParam3 = optionalParam3; return this; &#125; public Builder optionalParam4(String optionalParam4)&#123; this.optionalParam4 = optionalParam4; return this; &#125; public Builder optionalParam5(String optionalParam5)&#123; this.optionalParam5 = optionalParam5; return this; &#125; //使用无参构造函数来构建目标对象 public A build()&#123; //调用目标对象的私有构造函数来创建对象，并返回 return new A(this); &#125; &#125; //私有构造函数中传入构建器对象来初始化目标对象 private A(Builder builder)&#123; this.requiredParam1 = builder.requiredParam1; this.requiredParam2 = builder.requiredParam2; this.optionalParam3 = builder.optionalParam3; this.optionalParam4 = builder.optionalParam4; this.optionalParam5 = builder.optionalParam5; &#125; @Override public String toString() &#123; return "A&#123;" + "requiredParam1='" + requiredParam1 + '\'' + ", requiredParam2='" + requiredParam2 + '\'' + ", optionalParam3='" + optionalParam3 + '\'' + ", optionalParam4='" + optionalParam4 + '\'' + ", optionalParam5='" + optionalParam5 + '\'' + '&#125;'; &#125;&#125; 这里的Builder可以看成是目标对象参数的收集器和创建者，首先是收集必要的参数，然后收集可选参数，最后创建目标对象。 3.用私有构造器强化Singleton属性12345class SingletonInstance&#123; //公有，静态，final实例变量 public static final SingletonInstance INSTANCE = new SingletonInstance(); private SingletonInstance()&#123;/**/&#125;&#125; 或者 1234567class SingletonInstance&#123; private static final SingletonInstance INSTANCE = new SingletonInstance(); private SingletonInstance()&#123;/**/&#125; public SingletonInstance getInstance()&#123; return INSTANCE; &#125;&#125; 4.通过私有构造器强化不可实例化的能力通常一些工具类可以定义为只含静态属性和方法的类，不需要被实例化，可以通过私有构造函数加以限制。例如JDK中的java.lang.Math和java.util.Collections。 5.优先考虑依赖注入引入资源当一个类要依赖一个或多个资源，例如一个拼写检查器需要依赖于字典，静态工厂方法和单例可以实现，但有不同字典的话，这两种方法显然是不同的。所以需要将字典或字典工厂注入到拼写检查器中。 1234567891011class SpellChecker&#123; //将资源定义为不可变 private final Lexicon dictionary; //通过构造器注入 public SpellChecker(Lexicon dictionary)&#123; this.dictionary = dictionary; &#125; public boolean isValid(String word)&#123; /**/ &#125;&#125; 总之，不要用Singleton和静态工具类来实现依赖一个或多个底层资源的类，且该资源的行为会影响该类的行为；也不要直接用这个类来创建这些资源，而应该将这些资源或者工厂传递给构造器(静态工厂或构建器)，通过他们来创建类，可以提供类的灵活性、可重用性和可测性。 6.避免创建不必要的对象一般尽量重用对象。一个对象是不可变的，那么它就可以被重用。 7.消除过期的对象引用只要是自己管理内存，就要警惕内存泄露问题。 12345678public Object pop()&#123; if(size == 0)&#123; throw new EmptyStackException(); &#125; Object result = elements[--size]; elements[size] = null;//消除过期引用 return result;&#125; 8.避免使用中介方法和清除方法垃圾回收最好还是让GC自己处理，不要手动。 9.try-with-resources优先于try-finallyJava7引入了try-with-resources语法，可以自动关闭资源，但有一个前提是该资源实现或扩展了AutoCloseable接口。下面是FileInputStream实现AutoCloseabe接口的代码， 123456789101112131415161718192021222324public void close() throws IOException &#123; if (closed) &#123; return; &#125; synchronized (closeLock) &#123; if (closed) &#123; return; &#125; closed = true; &#125; FileChannel fc = channel; if (fc != null) &#123; // possible race with getChannel(), benign since // FileChannel.close is final and idempotent fc.close(); &#125; fd.closeAll(new Closeable() &#123; public void close() throws IOException &#123; close0(); &#125; &#125;); &#125; 在 try语句块后，会自动调用该close方法。还有一点的是，Closeable接口继承了AutoCloseable接口，所以实现了Closeable也就实现了AutoCloseable接口 简单试用一下该语法，下面是是一个文件复制的例子， 1234567891011121314static void copy(String src,String dst)&#123; //定义两个资源 try(InputStream in = new FileInputStream(src); OutputStream out = new FileOutputStream(dst) )&#123; byte[] buf = new byte[BUFFER_SIZE]; int n; while((n = in.read(buf)) &gt;= 0)&#123; out.write(buf,0,n); &#125; &#125;catch(IOException ex)&#123;//同样可以使用catch语句 ex.printStackTrace(); &#125; &#125; 代码简洁、清晰! 参考文献 Effective Java中文版（第3版）]]></content>
      <categories>
        <category>basic-java</category>
      </categories>
      <tags>
        <tag>basic-java</tag>
        <tag>effective-java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis数据类型]]></title>
    <url>%2F2019%2F10%2F19%2Fredis%2F1.redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Redis是一个速度非常块的非关系型数据库，可以存储key和5种不同数据类型的value之间的映射，还支持持久化、主从复制(增加读性能)、分片(扩展写性能)。 Redis提供五种基本数据类型，分别为string,list,set,hash,zset。注意一点是，这里的数据类型指的是value的数据类型,而key都是字符串类型 结构类型 结构存储的值 能力 string 字符串、整数、浮点数 字符串进行操作；整数和浮点数自增、自减 list 链表，每个节点包含一个字符串 两端推入和推出元素；修剪；查找移除元素 set 无序，唯一 集合计算 hash 包含键值对的无需散列表 添加、获取、移除元素 zset 字符串成员（member）与浮点数分值（score）之间的有序映射，元素的排列顺序由分值的大小决定 添加、获取、移除元素 string1key:value 常用命令: set get del list1234567listKey: item1 item2 item3 ... itemn//有序，可重复 常用命令: rpush lrange lindex lpop set1234567setKey: item2 item1 itemn ... item3//无序，不可重复 常用命令： sadd sismember srem smembers hash123456hashKey: subKey1:value1 subKey2:value2 ... sunKeyn:valuen//subKey无序，不重复 常用命令： hset hget hdel zset123456zsetKey: member1:score1 member2:score2 ... membern:scoren//score为浮点数，每个成员按照score排序， 常用命令: zadd zrange zrem zrangebyscore 使用Jedis练习一下 依赖: 12redis-client: jedistest-tool: junit-jupiter-api 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import org.junit.jupiter.api.BeforeAll;import org.junit.jupiter.api.Test;import redis.clients.jedis.Jedis;import java.util.HashMap;import java.util.Map;public class Redis1Th &#123; public static Jedis jedis; @BeforeAll public static void setRedisConfig()&#123; jedis = new Jedis("127.0.0.1",6379); jedis.auth("redispassword"); &#125; @Test public void testString()&#123; //存在该key，则覆盖; 不存在该key，则创建 jedis.set("id","2"); //获取 print(jedis.get("id"));// 2 //增加一定的增量 jedis.incrBy("id",2L); print(jedis.get("id")); // 4 //删除key值对 jedis.del("id"); print(jedis.get("id"));// null &#125; @Test public void testList()&#123; //不存在该key，则会自动创建 //左进 jedis.lpush("hobbies","basketball","swimming"); //lrange(key,0,-1)返回该key的所有value print(jedis.lrange("hobbies",0,-1)); //[swimming, basketball] //右进 jedis.rpush("hobbies","game"); print(jedis.lrange("hobbies",0,-1));//[swimming, basketball, game] //右出 jedis.rpop("hobbies"); print(jedis.lrange("hobbies",0,-1));//[swimming, basketball] //左出 jedis.lpop("hobbies"); print(jedis.lrange("hobbies",0,-1));//[basketball] //取该key的指定的下标的值 print(jedis.lindex("hobbies",0));//basketball //通过list的rpush/rpop和lpush/lpop可以模拟栈和队列 &#125; @Test public void testSet()&#123; //key不存在创建并加入元素 jedis.sadd("ids","1"); print(jedis.sadd("ids","1"));// 0,有重复，添加失败 jedis.sadd("ids","2"); //查询该key对应的所有value print(jedis.smembers("ids")); //[1, 2] //删除指定key的value jedis.srem("ids","2"); print(jedis.smembers("ids")); //[1] //判断该key是否存在该value print(jedis.sismember("ids","1")); // true print(jedis.smembers("ids")); //[1] &#125; @Test public void testHash()&#123; Map&lt;String,String&gt; hashValues = new HashMap&lt;&gt;(2); hashValues.put("name","young"); hashValues.put("age","21"); //key-hashValues jedis.hset("user",hashValues); //取key的多个subKey对应的值 print(jedis.hmget("user","name","age")); //[young, 21] //取key所有subKey print(jedis.hkeys("user")); //[age, name] //取key所有subKey对应的value print(jedis.hvals("user")); //[21, young] jedis.hdel("user","age"); //删除key的subkey-subValue print(jedis.hkeys("user")); //[ name] &#125; @Test public void testZSet()&#123; Map&lt;String,Double&gt; grades = new HashMap&lt;&gt;(2); grades.put("tom",85.0D); grades.put("bob",90.0D); grades.put("alice",80.0D); grades.put("henry",86.0D); grades.put("jerry",91.0D); jedis.zadd("game",grades); //返回按照score排序(升序)后名次在start~stop的member print(jedis.zrange("game",0,2)); //[alice, tom, henry] //返回按照score在min~max的member print(jedis.zrangeByScore("game",80,90)); //[alice, tom, henry, bob] &#125; public static void print(Object o)&#123; System.out.println(o); &#125;&#125; 参考资料: Redis 实战]]></content>
      <categories>
        <category>redis基础</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>非关系型数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间格式化]]></title>
    <url>%2F2019%2F10%2F14%2Fweb%2Fweb%2F</url>
    <content type="text"><![CDATA[在web开发时，令人很烦的就是的时间格式，前端传到后端，后端传到数据库，然后又取出来传递到前端，时间每次都要转换，想当麻烦。有了@DateTimeFormat和@JsonFormat,省时又省力。 环境 数据库有一个字段是datetime类型 请求实体类ReqVo有个String类型yyyy-MM-dd HH:mm:ss字符串 一个Entity类有一个属性是LocalDateTime类型的变量 @DateTimeFormat当前端通过Json串传进来时间格式字符串str，需要转换为LocalDateTime类型,只需在ReqVo的属性上添加@DateTimeFormat注解。str必须符合pattern的格式，方能转化为LocalDateTime ReqVo.java 1234import org.springframework.format.annotation.DateTimeFormat; //由spring自身提供@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") //24小时制private LocalDateTime birthday; @JsonFormat当LocalDateTime类型变量通过Json串向前端传递时,需要格式为字符串，就在实体类加上注解@JsonFormat Entity.java 1234import com.fasterxml.jackson.annotation.JsonFormat;//springboot自带Json转换器@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")private LocalDateTime birthday; 后台与数据库之间在使用Mybatis作为ORM工具时，格式自动转换，不用人工干预]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spirngboot整合Mybatis]]></title>
    <url>%2F2019%2F10%2F12%2FSpringBoot%2F2.SpringBoot%E6%95%B4%E5%90%88Druid%2BMybatis%2F</url>
    <content type="text"><![CDATA[依赖包括MySQLs数据驱动包，MyBatis与SpringBoot整合的包，Druid与SpringBoo整合的包 12345678910111213141516171819202122&lt;!--MySql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--SpringBoot整合Mybatis--&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--druid数据源--&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.20&lt;/version&gt; &lt;/dependency&gt; application.yml配置12345678910111213141516171819202122232425262728server: port: 8081spring: datasource: username: root password: root url: jdbc:mysql://127.0.0.1:3306/practice?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8 #可以不指定数据库驱动包 type: com.alibaba.druid.pool.DruidDataSource #指定数据源类型 druid: #配置druid filters: stat maxActive: 20 initialSize: 1 maxWait: 60000 minIdle: 1 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: select 'x' testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true maxOpenPreparedStatements: 20mybatis: #配置mybatis mapper-locations: classpath:mapper/*.xml #配置mapper路径 type-aliases-package: com.younger.springbootstart.model #设置别名包 configuration: map-underscore-to-camel-case: true #下划线转驼峰 Dao和Mapper1234@Mapperpublic interface StudentDao &#123; List&lt;Student&gt; selectAll();&#125; 12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.younger.springbootstart.dao.StudentDao"&gt; &lt;select id="selectAll" resultType="student"&gt; select * from `student` &lt;/select&gt;&lt;/mapper&gt; 注意使用@Mapper注解标识Dao接口，而在Spring Framwork中使用@Repository注解，而Mapper文件问你件没有区别]]></content>
      <categories>
        <category>springboot 基础</category>
      </categories>
      <tags>
        <tag>spirngboot 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spirngboot 基础]]></title>
    <url>%2F2019%2F10%2F12%2FSpringBoot%2F1.SpringBoot%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[例子12345678//springboot 启动类@SpringBootApplicationpublic class SpringBootStartApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootStartApplication.class, args); &#125;&#125; @SpringBootApplication 含义 123456789101112131415161718//SpringBootApplication注解@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan //spring注解,开启包扫描public @interface SpringBootApplication &#123; //...&#125;//SpringBootConfiguration注解：标注该类为配置类@Configurationpublic @interface SpringBootConfiguration &#123;&#125;//EnableAutoConfiguration注解：标注自动加载默认配置@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123;&#125; 2.HelloController12345678@RestControllerpublic class HelloController &#123; @RequestMapping(value="/hello") public String hello()&#123; return "hello !"; &#125;&#125; RestController注解 1234@Controller@ResponseBodypublic @interface RestController &#123;&#125; 如果Controller Method返回的数据是基本数据类型和String，则前台获取到的数据仍为基本数据类型和String类型。如果返回对象或Map则为Json格式数据 yaml基本语法1.基本形式12345678910#基本语法k: v # ':'有一个空格# 缩进来表示层级关系# 属性和值大小写敏感 server: port: 9090 path: /test 2.值的形式字面量: 数字、字符串、布尔值 字符串默认不需要添加引号。单引号对特殊字符转义，双引号对特殊字符不转义 对象、Map（k:v） 123student: name: young age: 18 数组(List、Set) 123fruits: - apple - orange 从配置文件获取值1.@ConfigurationProperties123@ConfigurationProperties(prefix = "prefix")//整体读取一系列配置字段//类属性名称和配置文件中字段名称一一映射 12345678@Data@AllArgsConstructor@NoArgsConstructorpublic class Student &#123; Integer id; private String name; private Integer age;&#125; 1234student: id: 123 name: young age: 18 12345678910111213141516171819202122//使用方法一：直接标注在类上，同时要注入容器中@Data@AllArgsConstructor@NoArgsConstructor@Component@ConfigurationProperties(prefix = "stu")public class Student &#123; Integer id; private String name; private Integer age;&#125;//使用方法二: 使用配置类@Configurationpublic class MyConfig &#123; @Bean @ConfigurationProperties(prefix = "student") public Student student()&#123; return new Student(); &#125;&#125; 2.@Value12@Value("$&#123;prefix.attr&#125;")// 单一读取一个配置字段 12345678910111213//使用@Data@AllArgsConstructor@NoArgsConstructor@Componentpublic class Student &#123; @Value("$&#123;stu.id&#125;") Integer id; @Value("$&#123;stu.name&#125;") private String name; @Value("$&#123;stu.age&#125;") private Integer age;&#125; 3.@ConfigurationProperties和@Value获取值比较 @ConfigurationProperties @Value 注入方式 整体注入 单个注入 松散绑定 支持 不支持 SpEL 不支持 支持 JSR303校验 支持 不支持 复合数据类型数据 支持 不支持 4.@PropertySource为了避免把所有的配置放在一个配置文件，可以创建其他配置文件，然后利用@PropertySource。 1234567891011@Data@AllArgsConstructor@NoArgsConstructor@PropertySource(&#123;"classpath:stu.properties"&#125;) //指定特定的属性配置文件@ConfigurationProperties(prefix = "stu") //必须指定@Componentpublic class Student &#123; Integer id; private String name; private Integer age;&#125; 1234# stu.propertiesstu.id=123stu.name=youngstu.age=18 即使指定从特定的配置文件读取数据，当其中的配置属性和主配置中的属性相同，最终会读取主配置，也即主配置文件优先级大于其他配置文件 配置文件占位符1.随机数123# $&#123;random.int&#125; $&#123;random.long&#125; $&#123;random.value&#125; $&#123;random.uuid&#125;stu: id: $&#123;random.uuid&#125; 2.占位符可以在后面使用前面配置属性变量 123456nameTest: hahastu: id: 123 name: $&#123;nameTest:hehe&#125; # 当nameTest属性变量不存在时，可以指定默认值 age: 20 Profile1.多Profile文件在不同环境下，可以主配置文件(applicaiton.properties或application.yml)， 同时可以有对应环境下的配置文件。优先使用主配置文件 1234# 模式： application-&#123;profileName&#125;.properties/ymlapplication-dev.ymlapplication-test.ymlapplication-prod.yml 2.激活1234567# 在 application.yml中激活配置文件# 模式： spring.profiles.active = profileNamespring: profiles: active: dev #激活application-dev.yaml配置文件# 也可以通过 虚拟机参数或者命令行参数来激活，具体方式略 日志1.日志框架选用SLF4J(抽象层) + logback(实现层)，同时也是SpringBoot 默认是使用的日志框架 2.SLF4J的使用12345678910111213141516Logger logger = LoggerFactory.getLogger(Class);logger.trace(message);/**** 日志级别(由低到高): trace &lt; debug &lt; info &lt; warn &lt; error** 日志输出规则: 输出级别 &gt;= 当前设定的日志级别** springboot 默认级别: info*/logger.trace("trace日志");logger.debug("debug日志");logger.info("info日志");logger.warn("warn日志");logger.error("error日志"); 123logging: level: debug #定义全局日志级别 ClasssFullyQualifiedName: info #定义局部某个类的级别]]></content>
      <categories>
        <category>springboot 基础</category>
      </categories>
      <tags>
        <tag>spirngboot 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList.md]]></title>
    <url>%2F2019%2F10%2F05%2Fjdk%2FArrayList%2F</url>
    <content type="text"><![CDATA[变长数组 基于JDK9，有的源码上有英文注释，将不再做过多的注解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319132013211322132313241325132613271328132913301331133213331334133513361337133813391340134113421343134413451346134713481349135013511352135313541355135613571358135913601361136213631364136513661367136813691370137113721373137413751376137713781379138013811382138313841385138613871388138913901391139213931394139513961397139813991400140114021403140414051406140714081409141014111412141314141415141614171418141914201421142214231424142514261427142814291430143114321433143414351436143714381439144014411442144314441445144614471448144914501451145214531454145514561457145814591460146114621463146414651466146714681469147014711472147314741475147614771478147914801481148214831484148514861487148814891490149114921493149414951496149714981499150015011502150315041505150615071508150915101511151215131514151515161517151815191520152115221523152415251526152715281529153015311532153315341535153615371538153915401541154215431544154515461547154815491550155115521553155415551556155715581559156015611562156315641565156615671568156915701571157215731574157515761577157815791580158115821583158415851586158715881589159015911592159315941595159615971598/* * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. * * * * * * * * * * * * * * * * * * * * */package java.util;import java.util.function.Consumer;import java.util.function.Predicate;import java.util.function.UnaryOperator;import jdk.internal.misc.SharedSecrets;/** * Resizable-array implementation of the &#123;@code List&#125; interface. Implements * all optional list operations, and permits all elements, including * &#123;@code null&#125;. In addition to implementing the &#123;@code List&#125; interface, * this class provides methods to manipulate the size of the array that is * used internally to store the list. (This class is roughly equivalent to * &#123;@code Vector&#125;, except that it is unsynchronized.) * * &lt;p&gt;The &#123;@code size&#125;, &#123;@code isEmpty&#125;, &#123;@code get&#125;, &#123;@code set&#125;, * &#123;@code iterator&#125;, and &#123;@code listIterator&#125; operations run in constant * time. The &#123;@code add&#125; operation runs in &lt;i&gt;amortized constant time&lt;/i&gt;, * that is, adding n elements requires O(n) time. All of the other operations * run in linear time (roughly speaking). The constant factor is low compared * to that for the &#123;@code LinkedList&#125; implementation. * * &lt;p&gt;Each &#123;@code ArrayList&#125; instance has a &lt;i&gt;capacity&lt;/i&gt;. The capacity is * the size of the array used to store the elements in the list. It is always * at least as large as the list size. As elements are added to an ArrayList, * its capacity grows automatically. The details of the growth policy are not * specified beyond the fact that adding an element has constant amortized * time cost. * * &lt;p&gt;An application can increase the capacity of an &#123;@code ArrayList&#125; instance * before adding a large number of elements using the &#123;@code ensureCapacity&#125; * operation. This may reduce the amount of incremental reallocation. * * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt; * If multiple threads access an &#123;@code ArrayList&#125; instance concurrently, * and at least one of the threads modifies the list structurally, it * &lt;i&gt;must&lt;/i&gt; be synchronized externally. (A structural modification is * any operation that adds or deletes one or more elements, or explicitly * resizes the backing array; merely setting the value of an element is not * a structural modification.) This is typically accomplished by * synchronizing on some object that naturally encapsulates the list. * * If no such object exists, the list should be "wrapped" using the * &#123;@link Collections#synchronizedList Collections.synchronizedList&#125; * method. This is best done at creation time, to prevent accidental * unsynchronized access to the list:&lt;pre&gt; * List list = Collections.synchronizedList(new ArrayList(...));&lt;/pre&gt; * * &lt;p id="fail-fast"&gt; * The iterators returned by this class's &#123;@link #iterator() iterator&#125; and * &#123;@link #listIterator(int) listIterator&#125; methods are &lt;em&gt;fail-fast&lt;/em&gt;: * if the list is structurally modified at any time after the iterator is * created, in any way except through the iterator's own * &#123;@link ListIterator#remove() remove&#125; or * &#123;@link ListIterator#add(Object) add&#125; methods, the iterator will throw a * &#123;@link ConcurrentModificationException&#125;. Thus, in the face of * concurrent modification, the iterator fails quickly and cleanly, rather * than risking arbitrary, non-deterministic behavior at an undetermined * time in the future. * * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed * as it is, generally speaking, impossible to make any hard guarantees in the * presence of unsynchronized concurrent modification. Fail-fast iterators * throw &#123;@code ConcurrentModificationException&#125; on a best-effort basis. * Therefore, it would be wrong to write a program that depended on this * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators * should be used only to detect bugs.&lt;/i&gt; * * &lt;p&gt;This class is a member of the * &lt;a href="&#123;@docRoot&#125;/java/util/package-summary.html#CollectionsFramework"&gt; * Java Collections Framework&lt;/a&gt;. * * @param &lt;E&gt; the type of elements in this list * * @author Josh Bloch * @author Neal Gafter * @see Collection * @see List * @see LinkedList * @see Vector * @since 1.2 */public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; /** * Default initial capacity. */ private static final int DEFAULT_CAPACITY = 10; /** * Shared empty array instance used for empty instances. */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */ //注意使用Object数组来存储元素 transient Object[] elementData; // non-private to simplify nested class access /** * The size of the ArrayList (the number of elements it contains). * * @serial */ private int size; /** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125; /** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // defend against c.toArray (incorrectly) not returning Object[] // (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; /** * Trims the capacity of this &#123;@code ArrayList&#125; instance to be the * list's current size. An application can use this operation to minimize * the storage of an &#123;@code ArrayList&#125; instance. */ public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125; /** * Increases the capacity of this &#123;@code ArrayList&#125; instance, if * necessary, to ensure that it can hold at least the number of elements * specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ public void ensureCapacity(int minCapacity) &#123; if (minCapacity &gt; elementData.length &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) &#123; modCount++; grow(minCapacity); &#125; &#125; /** * The maximum size of array to allocate (unless necessary). * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity * @throws OutOfMemoryError if minCapacity is less than zero */ private Object[] grow(int minCapacity) &#123; return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity)); &#125; private Object[] grow() &#123; return grow(size + 1); &#125; /** * Returns a capacity at least as large as the given minimum capacity. * Returns the current capacity increased by 50% if that suffices. * Will not return a capacity greater than MAX_ARRAY_SIZE unless * the given minimum capacity is greater than MAX_ARRAY_SIZE. * * @param minCapacity the desired minimum capacity * @throws OutOfMemoryError if minCapacity is less than zero */ private int newCapacity(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt;= 0) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) return Math.max(DEFAULT_CAPACITY, minCapacity); if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return minCapacity; &#125; return (newCapacity - MAX_ARRAY_SIZE &lt;= 0) ? newCapacity : hugeCapacity(minCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; /** * Returns the number of elements in this list. * * @return the number of elements in this list */ public int size() &#123; return size; &#125; /** * Returns &#123;@code true&#125; if this list contains no elements. * * @return &#123;@code true&#125; if this list contains no elements */ public boolean isEmpty() &#123; return size == 0; &#125; /** * Returns &#123;@code true&#125; if this list contains the specified element. * More formally, returns &#123;@code true&#125; if and only if this list contains * at least one element &#123;@code e&#125; such that * &#123;@code Objects.equals(o, e)&#125;. * * @param o element whose presence in this list is to be tested * @return &#123;@code true&#125; if this list contains the specified element */ public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125; /** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &#123;@code i&#125; such that * &#123;@code Objects.equals(o, get(i))&#125;, * or -1 if there is no such index. */ public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * Returns the index of the last occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the highest index &#123;@code i&#125; such that * &#123;@code Objects.equals(o, get(i))&#125;, * or -1 if there is no such index. */ public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * Returns a shallow copy of this &#123;@code ArrayList&#125; instance. (The * elements themselves are not copied.) * * @return a clone of this &#123;@code ArrayList&#125; instance */ public Object clone() &#123; try &#123; ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(e); &#125; &#125; /** * Returns an array containing all of the elements in this list * in proper sequence (from first to last element). * * &lt;p&gt;The returned array will be "safe" in that no references to it are * maintained by this list. (In other words, this method must allocate * a new array). The caller is thus free to modify the returned array. * * &lt;p&gt;This method acts as bridge between array-based and collection-based * APIs. * * @return an array containing all of the elements in this list in * proper sequence */ public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; /** * Returns an array containing all of the elements in this list in proper * sequence (from first to last element); the runtime type of the returned * array is that of the specified array. If the list fits in the * specified array, it is returned therein. Otherwise, a new array is * allocated with the runtime type of the specified array and the size of * this list. * * &lt;p&gt;If the list fits in the specified array with room to spare * (i.e., the array has more elements than the list), the element in * the array immediately following the end of the collection is set to * &#123;@code null&#125;. (This is useful in determining the length of the * list &lt;i&gt;only&lt;/i&gt; if the caller knows that the list does not contain * any null elements.) * * @param a the array into which the elements of the list are to * be stored, if it is big enough; otherwise, a new array of the * same runtime type is allocated for this purpose. * @return an array containing the elements of the list * @throws ArrayStoreException if the runtime type of the specified array * is not a supertype of the runtime type of every element in * this list * @throws NullPointerException if the specified array is null */ @SuppressWarnings("unchecked") public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; // Positional Access Operations @SuppressWarnings("unchecked") E elementData(int index) &#123; return (E) elementData[index]; &#125; @SuppressWarnings("unchecked") static &lt;E&gt; E elementAt(Object[] es, int index) &#123; return (E) es[index]; &#125; /** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E get(int index) &#123; Objects.checkIndex(index, size); return elementData(index); &#125; /** * Replaces the element at the specified position in this list with * the specified element. * * @param index index of the element to replace * @param element element to be stored at the specified position * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E set(int index, E element) &#123; Objects.checkIndex(index, size); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; /** * This helper method split out from add(E) to keep method * bytecode size under 35 (the -XX:MaxInlineSize default value), * which helps when add(E) is called in a C1-compiled loop. */ private void add(E e, Object[] elementData, int s) &#123; if (s == elementData.length) elementData = grow(); elementData[s] = e; size = s + 1; &#125; /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; modCount++; add(e, elementData, size); return true; &#125; /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public void add(int index, E element) &#123; rangeCheckForAdd(index); modCount++; final int s; Object[] elementData; if ((s = size) == (elementData = this.elementData).length) elementData = grow(); System.arraycopy(elementData, index, elementData, index + 1, s - index); elementData[index] = element; size = s + 1; &#125; /** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E remove(int index) &#123; Objects.checkIndex(index, size); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; /** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &#123;@code i&#125; such that * &#123;@code Objects.equals(o, get(i))&#125; * (if such an element exists). Returns &#123;@code true&#125; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &#123;@code true&#125; if this list contained the specified element */ public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; /** * Private remove method that skips bounds checking and does not * return the value removed. */ private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; /** * Removes all of the elements from this list. The list will * be empty after this call returns. */ public void clear() &#123; modCount++; final Object[] es = elementData; for (int to = size, i = size = 0; i &lt; to; i++) es[i] = null; &#125; /** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the * specified collection's Iterator. The behavior of this operation is * undefined if the specified collection is modified while the operation * is in progress. (This implies that the behavior of this call is * undefined if the specified collection is this list, and this * list is nonempty.) * * @param c collection containing elements to be added to this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); modCount++; int numNew = a.length; if (numNew == 0) return false; Object[] elementData; final int s; if (numNew &gt; (elementData = this.elementData).length - (s = size)) elementData = grow(s + numNew); System.arraycopy(a, 0, elementData, s, numNew); size = s + numNew; return true; &#125; /** * Inserts all of the elements in the specified collection into this * list, starting at the specified position. Shifts the element * currently at that position (if any) and any subsequent elements to * the right (increases their indices). The new elements will appear * in the list in the order that they are returned by the * specified collection's iterator. * * @param index index at which to insert the first element from the * specified collection * @param c collection containing elements to be added to this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws NullPointerException if the specified collection is null */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); modCount++; int numNew = a.length; if (numNew == 0) return false; Object[] elementData; final int s; if (numNew &gt; (elementData = this.elementData).length - (s = size)) elementData = grow(s + numNew); int numMoved = s - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size = s + numNew; return true; &#125; /** * Removes from this list all of the elements whose index is between * &#123;@code fromIndex&#125;, inclusive, and &#123;@code toIndex&#125;, exclusive. * Shifts any succeeding elements to the left (reduces their index). * This call shortens the list by &#123;@code (toIndex - fromIndex)&#125; elements. * (If &#123;@code toIndex==fromIndex&#125;, this operation has no effect.) * * @throws IndexOutOfBoundsException if &#123;@code fromIndex&#125; or * &#123;@code toIndex&#125; is out of range * (&#123;@code fromIndex &lt; 0 || * toIndex &gt; size() || * toIndex &lt; fromIndex&#125;) */ protected void removeRange(int fromIndex, int toIndex) &#123; if (fromIndex &gt; toIndex) &#123; throw new IndexOutOfBoundsException( outOfBoundsMsg(fromIndex, toIndex)); &#125; modCount++; shiftTailOverGap(elementData, fromIndex, toIndex); &#125; /** Erases the gap from lo to hi, by sliding down following elements. */ private void shiftTailOverGap(Object[] es, int lo, int hi) &#123; System.arraycopy(es, hi, es, lo, size - hi); for (int to = size, i = (size -= hi - lo); i &lt; to; i++) es[i] = null; &#125; /** * A version of rangeCheck used by add and addAll. */ private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * Constructs an IndexOutOfBoundsException detail message. * Of the many possible refactorings of the error handling code, * this "outlining" performs best with both server and client VMs. */ private String outOfBoundsMsg(int index) &#123; return "Index: "+index+", Size: "+size; &#125; /** * A version used in checking (fromIndex &gt; toIndex) condition */ private static String outOfBoundsMsg(int fromIndex, int toIndex) &#123; return "From Index: " + fromIndex + " &gt; To Index: " + toIndex; &#125; /** * Removes from this list all of its elements that are contained in the * specified collection. * * @param c collection containing elements to be removed from this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws ClassCastException if the class of an element of this list * is incompatible with the specified collection * (&lt;a href="Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) * @throws NullPointerException if this list contains a null element and the * specified collection does not permit null elements * (&lt;a href="Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;), * or if the specified collection is null * @see Collection#contains(Object) */ public boolean removeAll(Collection&lt;?&gt; c) &#123; return batchRemove(c, false, 0, size); &#125; /** * Retains only the elements in this list that are contained in the * specified collection. In other words, removes from this list all * of its elements that are not contained in the specified collection. * * @param c collection containing elements to be retained in this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws ClassCastException if the class of an element of this list * is incompatible with the specified collection * (&lt;a href="Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) * @throws NullPointerException if this list contains a null element and the * specified collection does not permit null elements * (&lt;a href="Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;), * or if the specified collection is null * @see Collection#contains(Object) */ public boolean retainAll(Collection&lt;?&gt; c) &#123; return batchRemove(c, true, 0, size); &#125; boolean batchRemove(Collection&lt;?&gt; c, boolean complement, final int from, final int end) &#123; Objects.requireNonNull(c); final Object[] es = elementData; final boolean modified; int r; // Optimize for initial run of survivors for (r = from; r &lt; end &amp;&amp; c.contains(es[r]) == complement; r++) ; if (modified = (r &lt; end)) &#123; int w = r++; try &#123; for (Object e; r &lt; end; r++) if (c.contains(e = es[r]) == complement) es[w++] = e; &#125; catch (Throwable ex) &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. System.arraycopy(es, r, es, w, end - r); w += end - r; throw ex; &#125; finally &#123; modCount += end - w; shiftTailOverGap(es, w, end); &#125; &#125; return modified; &#125; /** * Saves the state of the &#123;@code ArrayList&#125; instance to a stream * (that is, serializes it). * * @param s the stream * @throws java.io.IOException if an I/O error occurs * @serialData The length of the array backing the &#123;@code ArrayList&#125; * instance is emitted (int), followed by all of its elements * (each an &#123;@code Object&#125;) in the proper order. */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * Reconstitutes the &#123;@code ArrayList&#125; instance from a stream (that is, * deserializes it). * @param s the stream * @throws ClassNotFoundException if the class of a serialized object * could not be found * @throws java.io.IOException if an I/O error occurs */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // like clone(), allocate array based upon size not capacity SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size); Object[] elements = new Object[size]; // Read in all elements in the proper order. for (int i = 0; i &lt; size; i++) &#123; elements[i] = s.readObject(); &#125; elementData = elements; &#125; else if (size == 0) &#123; elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new java.io.InvalidObjectException("Invalid size: " + size); &#125; &#125; /** * Returns a list iterator over the elements in this list (in proper * sequence), starting at the specified position in the list. * The specified index indicates the first element that would be * returned by an initial call to &#123;@link ListIterator#next next&#125;. * An initial call to &#123;@link ListIterator#previous previous&#125; would * return the element with the specified index minus one. * * &lt;p&gt;The returned list iterator is &lt;a href="#fail-fast"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public ListIterator&lt;E&gt; listIterator(int index) &#123; rangeCheckForAdd(index); return new ListItr(index); &#125; /** * Returns a list iterator over the elements in this list (in proper * sequence). * * &lt;p&gt;The returned list iterator is &lt;a href="#fail-fast"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @see #listIterator(int) */ public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0); &#125; /** * Returns an iterator over the elements in this list in proper sequence. * * &lt;p&gt;The returned iterator is &lt;a href="#fail-fast"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @return an iterator over the elements in this list in proper sequence */ public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; /** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; // prevent creating a synthetic constructor Itr() &#123;&#125; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); final int size = ArrayList.this.size; int i = cursor; if (i &lt; size) &#123; final Object[] es = elementData; if (i &gt;= es.length) throw new ConcurrentModificationException(); for (; i &lt; size &amp;&amp; modCount == expectedModCount; i++) action.accept(elementAt(es, i)); // update once at end to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; /** * An optimized version of AbstractList.ListItr */ private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; @SuppressWarnings("unchecked") public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[lastRet = i]; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; ArrayList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; &#125; /** * Returns a view of the portion of this list between the specified * &#123;@code fromIndex&#125;, inclusive, and &#123;@code toIndex&#125;, exclusive. (If * &#123;@code fromIndex&#125; and &#123;@code toIndex&#125; are equal, the returned list is * empty.) The returned list is backed by this list, so non-structural * changes in the returned list are reflected in this list, and vice-versa. * The returned list supports all of the optional list operations. * * &lt;p&gt;This method eliminates the need for explicit range operations (of * the sort that commonly exist for arrays). Any operation that expects * a list can be used as a range operation by passing a subList view * instead of a whole list. For example, the following idiom * removes a range of elements from a list: * &lt;pre&gt; * list.subList(from, to).clear(); * &lt;/pre&gt; * Similar idioms may be constructed for &#123;@link #indexOf(Object)&#125; and * &#123;@link #lastIndexOf(Object)&#125;, and all of the algorithms in the * &#123;@link Collections&#125; class can be applied to a subList. * * &lt;p&gt;The semantics of the list returned by this method become undefined if * the backing list (i.e., this list) is &lt;i&gt;structurally modified&lt;/i&gt; in * any way other than via the returned list. (Structural modifications are * those that change the size of this list, or otherwise perturb it in such * a fashion that iterations in progress may yield incorrect results.) * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws IllegalArgumentException &#123;@inheritDoc&#125; */ public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList&lt;&gt;(this, fromIndex, toIndex); &#125; private static class SubList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess &#123; private final ArrayList&lt;E&gt; root; private final SubList&lt;E&gt; parent; private final int offset; private int size; /** * Constructs a sublist of an arbitrary ArrayList. */ public SubList(ArrayList&lt;E&gt; root, int fromIndex, int toIndex) &#123; this.root = root; this.parent = null; this.offset = fromIndex; this.size = toIndex - fromIndex; this.modCount = root.modCount; &#125; /** * Constructs a sublist of another SubList. */ private SubList(SubList&lt;E&gt; parent, int fromIndex, int toIndex) &#123; this.root = parent.root; this.parent = parent; this.offset = parent.offset + fromIndex; this.size = toIndex - fromIndex; this.modCount = root.modCount; &#125; public E set(int index, E element) &#123; Objects.checkIndex(index, size); checkForComodification(); E oldValue = root.elementData(offset + index); root.elementData[offset + index] = element; return oldValue; &#125; public E get(int index) &#123; Objects.checkIndex(index, size); checkForComodification(); return root.elementData(offset + index); &#125; public int size() &#123; checkForComodification(); return size; &#125; public void add(int index, E element) &#123; rangeCheckForAdd(index); checkForComodification(); root.add(offset + index, element); updateSizeAndModCount(1); &#125; public E remove(int index) &#123; Objects.checkIndex(index, size); checkForComodification(); E result = root.remove(offset + index); updateSizeAndModCount(-1); return result; &#125; protected void removeRange(int fromIndex, int toIndex) &#123; checkForComodification(); root.removeRange(offset + fromIndex, offset + toIndex); updateSizeAndModCount(fromIndex - toIndex); &#125; public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(this.size, c); &#125; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); int cSize = c.size(); if (cSize==0) return false; checkForComodification(); root.addAll(offset + index, c); updateSizeAndModCount(cSize); return true; &#125; public boolean removeAll(Collection&lt;?&gt; c) &#123; return batchRemove(c, false); &#125; public boolean retainAll(Collection&lt;?&gt; c) &#123; return batchRemove(c, true); &#125; private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; checkForComodification(); int oldSize = root.size; boolean modified = root.batchRemove(c, complement, offset, offset + size); if (modified) updateSizeAndModCount(root.size - oldSize); return modified; &#125; public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; checkForComodification(); int oldSize = root.size; boolean modified = root.removeIf(filter, offset, offset + size); if (modified) updateSizeAndModCount(root.size - oldSize); return modified; &#125; public Iterator&lt;E&gt; iterator() &#123; return listIterator(); &#125; public ListIterator&lt;E&gt; listIterator(int index) &#123; checkForComodification(); rangeCheckForAdd(index); return new ListIterator&lt;E&gt;() &#123; int cursor = index; int lastRet = -1; int expectedModCount = root.modCount; public boolean hasNext() &#123; return cursor != SubList.this.size; &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= SubList.this.size) throw new NoSuchElementException(); Object[] elementData = root.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[offset + (lastRet = i)]; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; @SuppressWarnings("unchecked") public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = root.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[offset + (lastRet = i)]; &#125; public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); final int size = SubList.this.size; int i = cursor; if (i &lt; size) &#123; final Object[] es = root.elementData; if (offset + i &gt;= es.length) throw new ConcurrentModificationException(); for (; i &lt; size &amp;&amp; modCount == expectedModCount; i++) action.accept(elementAt(es, offset + i)); // update once at end to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; SubList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = root.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; root.set(offset + lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; SubList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = root.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (root.modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125;; &#125; public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList&lt;&gt;(this, fromIndex, toIndex); &#125; private void rangeCheckForAdd(int index) &#123; if (index &lt; 0 || index &gt; this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private String outOfBoundsMsg(int index) &#123; return "Index: "+index+", Size: "+this.size; &#125; private void checkForComodification() &#123; if (root.modCount != modCount) throw new ConcurrentModificationException(); &#125; private void updateSizeAndModCount(int sizeChange) &#123; SubList&lt;E&gt; slist = this; do &#123; slist.size += sizeChange; slist.modCount = root.modCount; slist = slist.parent; &#125; while (slist != null); &#125; public Spliterator&lt;E&gt; spliterator() &#123; checkForComodification(); // ArrayListSpliterator not used here due to late-binding return new Spliterator&lt;E&gt;() &#123; private int index = offset; // current index, modified on advance/split private int fence = -1; // -1 until used; then one past last index private int expectedModCount; // initialized when fence set private int getFence() &#123; // initialize fence to size on first use int hi; // (a specialized variant appears in method forEach) if ((hi = fence) &lt; 0) &#123; expectedModCount = modCount; hi = fence = offset + size; &#125; return hi; &#125; public ArrayList&lt;E&gt;.ArrayListSpliterator trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; // ArrayListSpliterator can be used here as the source is already bound return (lo &gt;= mid) ? null : // divide range in half unless too small root.new ArrayListSpliterator(lo, index = mid, expectedModCount); &#125; public boolean tryAdvance(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); int hi = getFence(), i = index; if (i &lt; hi) &#123; index = i + 1; @SuppressWarnings("unchecked") E e = (E)root.elementData[i]; action.accept(e); if (root.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; return false; &#125; public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); int i, hi, mc; // hoist accesses and checks from loop ArrayList&lt;E&gt; lst = root; Object[] a; if ((a = lst.elementData) != null) &#123; if ((hi = fence) &lt; 0) &#123; mc = modCount; hi = offset + size; &#125; else mc = expectedModCount; if ((i = index) &gt;= 0 &amp;&amp; (index = hi) &lt;= a.length) &#123; for (; i &lt; hi; ++i) &#123; @SuppressWarnings("unchecked") E e = (E) a[i]; action.accept(e); &#125; if (lst.modCount == mc) return; &#125; &#125; throw new ConcurrentModificationException(); &#125; public long estimateSize() &#123; return getFence() - index; &#125; public int characteristics() &#123; return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED; &#125; &#125;; &#125; &#125; /** * @throws NullPointerException &#123;@inheritDoc&#125; */ @Override public void forEach(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); final int expectedModCount = modCount; final Object[] es = elementData; final int size = this.size; for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) action.accept(elementAt(es, i)); if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; /** * Creates a &lt;em&gt;&lt;a href="Spliterator.html#binding"&gt;late-binding&lt;/a&gt;&lt;/em&gt; * and &lt;em&gt;fail-fast&lt;/em&gt; &#123;@link Spliterator&#125; over the elements in this * list. * * &lt;p&gt;The &#123;@code Spliterator&#125; reports &#123;@link Spliterator#SIZED&#125;, * &#123;@link Spliterator#SUBSIZED&#125;, and &#123;@link Spliterator#ORDERED&#125;. * Overriding implementations should document the reporting of additional * characteristic values. * * @return a &#123;@code Spliterator&#125; over the elements in this list * @since 1.8 */ @Override public Spliterator&lt;E&gt; spliterator() &#123; return new ArrayListSpliterator(0, -1, 0); &#125; /** Index-based split-by-two, lazily initialized Spliterator */ final class ArrayListSpliterator implements Spliterator&lt;E&gt; &#123; /* * If ArrayLists were immutable, or structurally immutable (no * adds, removes, etc), we could implement their spliterators * with Arrays.spliterator. Instead we detect as much * interference during traversal as practical without * sacrificing much performance. We rely primarily on * modCounts. These are not guaranteed to detect concurrency * violations, and are sometimes overly conservative about * within-thread interference, but detect enough problems to * be worthwhile in practice. To carry this out, we (1) lazily * initialize fence and expectedModCount until the latest * point that we need to commit to the state we are checking * against; thus improving precision. (This doesn't apply to * SubLists, that create spliterators with current non-lazy * values). (2) We perform only a single * ConcurrentModificationException check at the end of forEach * (the most performance-sensitive method). When using forEach * (as opposed to iterators), we can normally only detect * interference after actions, not before. Further * CME-triggering checks apply to all other possible * violations of assumptions for example null or too-small * elementData array given its size(), that could only have * occurred due to interference. This allows the inner loop * of forEach to run without any further checks, and * simplifies lambda-resolution. While this does entail a * number of checks, note that in the common case of * list.stream().forEach(a), no checks or other computation * occur anywhere other than inside forEach itself. The other * less-often-used methods cannot take advantage of most of * these streamlinings. */ private int index; // current index, modified on advance/split private int fence; // -1 until used; then one past last index private int expectedModCount; // initialized when fence set /** Creates new spliterator covering the given range. */ ArrayListSpliterator(int origin, int fence, int expectedModCount) &#123; this.index = origin; this.fence = fence; this.expectedModCount = expectedModCount; &#125; private int getFence() &#123; // initialize fence to size on first use int hi; // (a specialized variant appears in method forEach) if ((hi = fence) &lt; 0) &#123; expectedModCount = modCount; hi = fence = size; &#125; return hi; &#125; public ArrayListSpliterator trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid) ? null : // divide range in half unless too small new ArrayListSpliterator(lo, index = mid, expectedModCount); &#125; public boolean tryAdvance(Consumer&lt;? super E&gt; action) &#123; if (action == null) throw new NullPointerException(); int hi = getFence(), i = index; if (i &lt; hi) &#123; index = i + 1; @SuppressWarnings("unchecked") E e = (E)elementData[i]; action.accept(e); if (modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; return false; &#125; public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; int i, hi, mc; // hoist accesses and checks from loop Object[] a; if (action == null) throw new NullPointerException(); if ((a = elementData) != null) &#123; if ((hi = fence) &lt; 0) &#123; mc = modCount; hi = size; &#125; else mc = expectedModCount; if ((i = index) &gt;= 0 &amp;&amp; (index = hi) &lt;= a.length) &#123; for (; i &lt; hi; ++i) &#123; @SuppressWarnings("unchecked") E e = (E) a[i]; action.accept(e); &#125; if (modCount == mc) return; &#125; &#125; throw new ConcurrentModificationException(); &#125; public long estimateSize() &#123; return getFence() - index; &#125; public int characteristics() &#123; return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED; &#125; &#125; // A tiny bit set implementation private static long[] nBits(int n) &#123; return new long[((n - 1) &gt;&gt; 6) + 1]; &#125; private static void setBit(long[] bits, int i) &#123; bits[i &gt;&gt; 6] |= 1L &lt;&lt; i; &#125; private static boolean isClear(long[] bits, int i) &#123; return (bits[i &gt;&gt; 6] &amp; (1L &lt;&lt; i)) == 0; &#125; /** * @throws NullPointerException &#123;@inheritDoc&#125; */ @Override public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; return removeIf(filter, 0, size); &#125; /** * Removes all elements satisfying the given predicate, from index * i (inclusive) to index end (exclusive). */ boolean removeIf(Predicate&lt;? super E&gt; filter, int i, final int end) &#123; Objects.requireNonNull(filter); int expectedModCount = modCount; final Object[] es = elementData; // Optimize for initial run of survivors for (; i &lt; end &amp;&amp; !filter.test(elementAt(es, i)); i++) ; // Tolerate predicates that reentrantly access the collection for // read (but writers still get CME), so traverse once to find // elements to delete, a second pass to physically expunge. if (i &lt; end) &#123; final int beg = i; final long[] deathRow = nBits(end - beg); deathRow[0] = 1L; // set bit 0 for (i = beg + 1; i &lt; end; i++) if (filter.test(elementAt(es, i))) setBit(deathRow, i - beg); if (modCount != expectedModCount) throw new ConcurrentModificationException(); expectedModCount++; modCount++; int w = beg; for (i = beg; i &lt; end; i++) if (isClear(deathRow, i - beg)) es[w++] = es[i]; shiftTailOverGap(es, w, end); return true; &#125; else &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); return false; &#125; &#125; @Override public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); final int expectedModCount = modCount; final Object[] es = elementData; final int size = this.size; for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) es[i] = operator.apply(elementAt(es, i)); if (modCount != expectedModCount) throw new ConcurrentModificationException(); modCount++; &#125; @Override @SuppressWarnings("unchecked") public void sort(Comparator&lt;? super E&gt; c) &#123; final int expectedModCount = modCount; Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) throw new ConcurrentModificationException(); modCount++; &#125; void checkInvariants() &#123; // assert size &gt;= 0; // assert size == elementData.length || elementData[size] == null; &#125;&#125;]]></content>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9--动态SQLr-foreach]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F9---%E5%8A%A8%E6%80%81SQL--foreach%2F</url>
    <content type="text"><![CDATA[foreach需要注意一点的是:collection为set list array时，index为集合的下标, item为元素值collection为map时，index为key,item为valuedao 1List&lt;Student&gt; listStudents(List&lt;Integer&gt; list); mapper 12345678&lt;select id=&quot;listStudents&quot; resultMap=&quot;studentMapper&quot;&gt; select * from `student` where `id` in &lt;foreach collection=&quot;list&quot; item=&quot;value&quot; index=&quot;indexOrKey&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #&#123;value&#125; &lt;/foreach&gt; &lt;/select&gt; test 12345678910111213141516171819202122@Testpublic void test() &#123; SqlSession session = factory.openSession(); try &#123; StudentMapper studentMapper = session.getMapper(StudentMapper.class); List&lt;Integer&gt; listIds = new ArrayList&lt;&gt;(); listIds.add(1000); listIds.add(10001); List&lt;Student&gt; students = studentMapper.listStudents(listIds); if(!students.isEmpty())&#123; for (Student student: students) &#123; System.out.println(student); &#125; &#125;else&#123; System.out.println(&quot;没有查到结果!&quot;); &#125; &#125; finally &#123; session.commit(); session.close(); &#125;&#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[8-动态SQLr-set]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F8---%E5%8A%A8%E6%80%81SQL--set%2F</url>
    <content type="text"><![CDATA[set ifdao 1int updateStudent(Student student); mapper 123456789101112131415&lt;update id=&quot;updateStudent&quot; parameterType=&quot;student&quot;&gt; update `student` &lt;set&gt; &lt;if test=&quot;name != null&quot;&gt; `name` = #&#123;name&#125;, &lt;/if&gt; &lt;if test=&quot;age != null&quot;&gt; `age` = #&#123;age&#125;, &lt;/if&gt; &lt;if test=&quot;gender != null&quot;&gt; `gender` = #&#123;gender,typeHandler=genderTypeHandler&#125; &lt;/if&gt; &lt;/set&gt; where `id` = #&#123;id&#125; &lt;/update&gt; test 12345678910111213141516171819@Testpublic void test() &#123; SqlSession session = factory.openSession(); try &#123; StudentMapper studentMapper = session.getMapper(StudentMapper.class); int id = 10001; String name = &quot;hu&quot;; int age = 18; GenderEnum gender = GenderEnum.getGender(1); Student student = new Student(id,name,age,gender); int affectedRows = studentMapper.updateStudent(student); System.out.println(affectedRows); System.out.println(studentMapper.selectStudentById(id)); &#125; finally &#123; session.commit(); session.close(); &#125;&#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[7--动态SQLr-where]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F7---%E5%8A%A8%E6%80%81SQL--where%2F</url>
    <content type="text"><![CDATA[where ifdao在含有int类型的查询参数，最好设置为Integer,以便接收null值 123List&lt;Student&gt; selectStudents(@Param(&quot;name&quot;) String name, @Param(&quot;age&quot;) Integer age, @Param(&quot;gender&quot;) GenderEnum gender); mapper 1234567891011121314&lt;select id=&quot;selectStudents&quot; resultMap=&quot;studentMapper&quot;&gt; select * from `student` &lt;where&gt; &lt;if test=&quot;name != null&quot;&gt; `name` like concat(&apos;%&apos;,#&#123;name&#125;,&apos;%&apos;) &lt;/if&gt; &lt;if test=&quot;age != null&quot;&gt; and `age` = #&#123;age&#125; &lt;/if&gt; &lt;if test=&quot;gender != null&quot;&gt; and `gender` = #&#123;gender,typeHandler=genderTypeHandler&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; test 1234567891011121314151617181920212223242526272829@Test public void test() &#123; SqlSession session = factory.openSession(); try &#123; StudentMapper studentMapper = session.getMapper(StudentMapper.class);// Student student = new Student(&quot;hu&quot;,19,GenderEnum.getGender(1));// int affectedRows = studentMapper.insertStudent(student); String name = &quot;h&quot;; int age = 20; GenderEnum gender = GenderEnum.getGender(2); List&lt;Student&gt; students = studentMapper.selectStudents(name, age,gender);// List&lt;Student&gt; students = studentMapper.selectStudents(name, age,null);// List&lt;Student&gt; students = studentMapper.selectStudents(name, null,gender);// List&lt;Student&gt; students = studentMapper.selectStudents(name, null,null);// List&lt;Student&gt; students = studentMapper.selectStudents(null, null,null); if(!students.isEmpty())&#123; Iterator&lt;Student&gt; it = students.iterator(); while(it.hasNext())&#123; Student student = it.next(); System.out.println(student); &#125; &#125;else&#123; System.out.println(&quot;没有查到结果&quot;); &#125; &#125; finally &#123; session.commit(); session.close(); &#125; &#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[6--TypeHandler-2]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F6---TypeHandler-2%2F</url>
    <content type="text"><![CDATA[本小节对枚举类型进行转换table 123456create table `student`(`id` int auto_increment primary key,`name` varchar(30) not null,`age` int,`gender` int default 0)auto_increment=10000; enum 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package model;public enum GenderEnum &#123; MALE(&quot;男&quot;,0),FEMALE(&quot;女&quot;,1),UNKNOW(&quot;不知道&quot;,2); private String gender; private int code; GenderEnum(String gender, int code)&#123; this.gender = gender; this.code = code; &#125; public static GenderEnum getGender(String genderName)&#123; for (GenderEnum gender: GenderEnum.values())&#123; if(gender.gender.equalsIgnoreCase(genderName))&#123; return gender; &#125; &#125; return null; &#125; public static GenderEnum getGender(int code)&#123; for (GenderEnum gender: GenderEnum.values())&#123; if(gender.code == code)&#123; return gender; &#125; &#125; return null; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; @Override public String toString() &#123; return &quot;GenderEnum&#123;&quot; + &quot;gender=&apos;&quot; + gender + &apos;\&apos;&apos; + &quot;, code=&quot; + code + &apos;&#125;&apos;; &#125;&#125; model 12345678910111213package model;public class Student &#123; private int id; private String name; private int age; private GenderEnum gender; public Student() &#123; &#125; //getter setter &#125; dao 1234public interface StudentMapper &#123; int insertStudent(Student student); Student selectStudentById(int id);&#125; mapper这里的typeHandler使用了别名 123456789101112131415161718&lt;insert id=&quot;insertStudent&quot; parameterType=&quot;student&quot;&gt; insert into `student`(`name`,`age`,`gender`) values(#&#123;name&#125;,#&#123;age&#125;,#&#123;gender,typeHandler=genderTypeHandler&#125;) &lt;selectKey resultType=&quot;int&quot; keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; order=&quot;AFTER&quot;&gt; select last_insert_id(); &lt;/selectKey&gt; &lt;/insert&gt; &lt;resultMap id=&quot;studentMapper&quot; type=&quot;student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt; &lt;result property=&quot;gender&quot; column=&quot;gender&quot; typeHandler=&quot;genderTypeHandler&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectStudentById&quot; parameterType=&quot;int&quot; resultMap=&quot;studentMapper&quot;&gt; select * from `student` where `id` = #&#123;id&#125; &lt;/select&gt; test 12]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[5--TypeHandler-1]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F5---TypeHandler-1%2F</url>
    <content type="text"><![CDATA[当需要将jdbc类型的数据和Java程序中类型的书数据进行转换时，可以使用TypeHandler来完成转换过程。怎么实现呢?Java类型==》jdbc将Java类型值value1通过某种策略转化为数据库(jdbc)类型值value2，然后将value2设置为SQL参数 :preparedStatement.setType(i,value2);Java类型《== jdbc从resultSet中取出值value2，然后通过某种策略将value2转换为Java类型值value1 table123456create table `student`(`id` int auto_increment primary key,`name` varchar(30) not null,`age` int,`birthday` varchar(30))auto_increment=10000; model123456789101112131415package model;import java.util.Date;public class Student &#123; private int id; private String name; private int age; private Date birthday;//在数据库中对应的类型是varchar(n) public Student() &#123; &#125;//getter和setter略&#125; TypeHandler123456789101112131415161718192021222324252627//表注转换的两种类型@MappedJdbcTypes(&#123;JdbcType.VARCHAR&#125;)//jdbc类型@MappedTypes(&#123;java.util.Date.class&#125;)//程序类型public class MyDateTypeHandler extends BaseTypeHandler&lt;Date&gt; &#123; @Override public void setNonNullParameter(PreparedStatement preparedStatement, int i, Date date, JdbcType jdbcType) throws SQLException &#123; preparedStatement.setString(i,String.valueOf(date.getTime())); &#125; @Override public Date getNullableResult(ResultSet resultSet, int i) throws SQLException &#123; return new Date(resultSet.getLong(i)); &#125; @Override public Date getNullableResult(ResultSet resultSet, String s) throws SQLException &#123; return new Date(resultSet.getLong(s)); &#125; @Override public Date getNullableResult(CallableStatement callableStatement, int i) throws SQLException &#123; return new Date(callableStatement.getLong(i)); &#125;&#125; dao12345678910package dao;import model.Student;public interface StudentMapper &#123; int insertStudent(Student student); Student selectStudentById(int id);&#125; mapper在对应参数处使用typeHandler来转换作为输入参数:#{birthday,typeHandler=dao.MyDateTypeHandler}这里的typeHandler的值不成写成字符串类型作为输出结果:&lt;result property=&quot;birthday&quot; column=&quot;birthday&quot; typeHandler=&quot;dao.MyDateTypeHandler&quot;/&gt; 123456789101112131415161718&lt;insert id=&quot;insertStudent&quot; parameterType=&quot;student&quot;&gt; insert into `student`(`name`,`age`,`birthday`) values(#&#123;name&#125;,#&#123;age&#125;,#&#123;birthday,typeHandler=dao.MyDateTypeHandler&#125;) &lt;selectKey resultType=&quot;int&quot; keyProperty=&quot;id&quot; keyColumn=&quot;id&quot; order=&quot;AFTER&quot;&gt; select last_insert_id() &lt;/selectKey&gt; &lt;/insert&gt; &lt;resultMap id=&quot;studentMapper&quot; type=&quot;student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot; typeHandler=&quot;dao.MyDateTypeHandler&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectStudentById&quot; parameterType=&quot;int&quot; resultMap=&quot;studentMapper&quot;&gt; select * from `student` where `id` = #&#123;id&#125; &lt;/select&gt; test1234567891011121314151617181920212223242526272829public class AppTest &#123; SqlSessionFactory factory = null; @Before public void prepare() throws IOException&#123; InputStream inputStream = Resources.getResourceAsStream(&quot;mybatis.xml&quot;); factory = new SqlSessionFactoryBuilder().build(inputStream); inputStream.close(); &#125; @Test public void test()&#123; SqlSession session = factory.openSession(); try&#123; StudentMapper studentMapper = session.getMapper(StudentMapper.class);// Student student = new Student(&quot;wang&quot;,20,new Date());// int affectedRows = studentMapper.insertStudent(student); int id=10001; Student student = studentMapper.selectStudentById(id); System.out.println(student); &#125;finally&#123; session.commit(); session.close(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[4--一对一]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F4---%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2~%E4%B8%80%E5%AF%B9%E4%B8%80%2F</url>
    <content type="text"><![CDATA[一本书只属于一个人!table 123456789101112create table `student`(`id` int auto_increment primary key,`name` varchar(30) not null,`age` int)auto_increment=10000;create table `book`(`id` int auto_increment primary key,`bookName` varchar(20),`author` varchar(10),`studentID` int references `student`(`id`))auto_increment=10000; model 123456789101112131415161718192021public class Student &#123; private int id; private String name; private int age; public Student()&#123;&#125; //getter setter略&#125;public class Book &#123; private int bookID; private String bookName; private String author; private Student student; public Book() &#123; &#125; //getter setter略&#125; dao 123public interface StudentMapper &#123; Book findBook(int bookID);&#125; mapper.xml方式一：嵌套 12345678910111213141516171819202122&lt;resultMap id=&quot;bookMapper&quot; type=&quot;book&quot;&gt; &lt;id column=&quot;bookID&quot; property=&quot;bookID&quot;/&gt; &lt;result column=&quot;bookName&quot; property=&quot;bookName&quot;/&gt; &lt;result column=&quot;author&quot; property=&quot;author&quot;/&gt; &lt;association property=&quot;student&quot; javaType=&quot;student&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;findBook&quot; resultMap=&quot;bookMapper&quot;&gt; select `student`.`id` `id`,`student`.`name` `name`, `student`.`age` `age`, `book`.`id` `bookID`, `book`.`bookName` `bookName`, `book`.`author` `author` from `student`,`book` where `student`.`id` = `book`.`studentID` and `book`.`id` = #&#123;bookID&#125;;&lt;/select&gt; 方式二:复用resultMapper 123456789101112131415161718192021222324 &lt;select id=&quot;findBook&quot; resultMap=&quot;bookMapper&quot;&gt; select `student`.`id` `id`, `student`.`name` `name`, `student`.`age` `age`, `book`.`id` `bookID`, `book`.`bookName` `bookName`, `book`.`author` `author` from `student`,`book` where `student`.`id` = `book`.`studentID` and `book`.`id` = #&#123;bookID&#125;; &lt;/select&gt;&lt;resultMap id=&quot;studentMapper&quot; type=&quot;student&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt; &lt;/resultMap&gt; &lt;resultMap id=&quot;bookMapper&quot; type=&quot;book&quot;&gt; &lt;id column=&quot;bookID&quot; property=&quot;bookID&quot;/&gt; &lt;result column=&quot;bookName&quot; property=&quot;bookName&quot;/&gt; &lt;result column=&quot;author&quot; property=&quot;author&quot;/&gt; &lt;association property=&quot;student&quot; resultMap=&quot;studentMapper&quot;/&gt; &lt;/resultMap&gt; 综合3、4关联查询两篇文章，总结一下1.明确实体之间的关系，优化范式，构建表2.依据业务，构建model3.编写关联查询语句 首先编写简单的model开始，建议使用resutlMap来映射，因为当SQL复杂时，嵌套很容易出错。然后依据一对一association或一对多collection来创建复杂实体。最后编写关联查询语句，注意返回字段的名称。需要注意两点: resultMap中的column属性必须和数据库返回字段相同 resultMap中的property属性必须和Model的成员属性相同]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[3--关联查询~一对多]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F3---%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2~%E4%B8%80%E5%AF%B9%E5%A4%9A%2F</url>
    <content type="text"><![CDATA[本小节将要介绍一对一、一对多的查询【技术上】。你有可能会问，多对多怎么查，这个问题就不该问！开玩笑的，哈哈。其实在设计表时，一般多对多的关系就已经转化为一对多了。 ###一对多就用一个学生有多本书籍来举例子吧!table 123456789101112create table `student`(`id` int auto_increment primary key,`name` varchar(30) not null,`age` int)auto_increment=10000;create table `book`(`id` int auto_increment primary key,`bookName` varchar(20),`author` varchar(10),`studentID` int references `student`(`id`))auto_increment=10000; model 123456789101112131415161718192021public class Student &#123; private int id; private String name; private int age; private List&lt;Book&gt; books; public Student() &#123;//无参构造函数===&gt;创建对象 &#125;//getter和setter略&#125;public class Book &#123; private int bookID; private String bookName; private String author; public Book() &#123; &#125;&#125;//getter和setter略 dao 123public interface StudentMapper &#123; Student findMyBooks(int id);&#125; mapple.xml方式一，直接嵌套 12345678910111213141516171819202122&lt;select id=&quot;findMyBooks&quot; resultMap=&quot;studentMapper&quot;&gt; select `student`.`id` `id`,`student`.`name` `name`, `student`.`age` `age`, `book`.`id` `bookID`, `book`.`bookName` `bookName`, `book`.`author` `author` from `student`,`book` where `student`.`id` = `book`.`studentID` and `student`.`id` = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id=&quot;studentMapper&quot; type=&quot;student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt; &lt;collection property=&quot;books&quot; ofType=&quot;book&quot;&gt; &lt;id property=&quot;bookID&quot; column=&quot;bookID&quot;/&gt; &lt;result property=&quot;bookName&quot; column=&quot;bookName&quot;/&gt; &lt;result property=&quot;author&quot; column=&quot;author&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 方式二：resultMap复用 123456789101112131415161718192021222324&lt;select id=&quot;findMyBooks&quot; resultMap=&quot;studentMapper&quot;&gt; select `student`.`id` `id`,`student`.`name` `name`, `student`.`age` `age`, `book`.`id` `bookID`, `book`.`bookName` `bookName`, `book`.`author` `author` from `student`,`book` where `student`.`id` = `book`.`studentID` and `student`.`id` = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id=&quot;bookMapper&quot; type=&quot;book&quot;&gt; &lt;id property=&quot;bookID&quot; column=&quot;bookID&quot;/&gt; &lt;result property=&quot;bookName&quot; column=&quot;bookName&quot;/&gt; &lt;result property=&quot;author&quot; column=&quot;author&quot;/&gt;&lt;/resultMap&gt;&lt;resultMap id=&quot;studentMapper&quot; type=&quot;student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt; &lt;collection property=&quot;books&quot; resultMap=&quot;bookMapper&quot;/&gt;&lt;/resultMap&gt; 关联查询必须用无参构造函数来创建对象，如果没有无参构造函数，就会报构造函数参数错误。希望能引起你的警觉。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1--基本CRUD]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F2---%E5%9F%BA%E6%9C%ACCURD%2F</url>
    <content type="text"><![CDATA[dao 123456789101112131415161718package dao;import model.Student;import java.util.List;public interface StudentMapper &#123; List&lt;Student&gt; selectAllStudent(); int insertStudent(Student student); int updateStudent(Student student); int deleteById(int id);&#125;​` mapple.xml 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;dao.StudentMapper&quot;&gt; &lt;select id=&quot;selectAllStudent&quot; resultType=&quot;student&quot;&gt; select * from `student` &lt;/select&gt; &lt;insert id=&quot;insertStudent&quot; parameterType=&quot;student&quot;&gt; insert into `student`(`name`,`age`) values(#&#123;name&#125;,#&#123;age&#125;) &lt;selectKey resultType=&quot;int&quot; keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; order=&quot;AFTER&quot;&gt; select last_insert_id(); &lt;/selectKey&gt; &lt;/insert&gt; &lt;update id=&quot;updateStudent&quot; parameterType=&quot;student&quot;&gt; update `student` set `name` = #&#123;name&#125;,`age` = #&#123;age&#125; where `id` = #&#123;id&#125; &lt;/update&gt; &lt;delete id=&quot;deleteById&quot; parameterType=&quot;int&quot;&gt; delete from `student` where `id` = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import dao.StudentMapper;import model.Student;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Iterator;import java.util.List;public class AppTest &#123; SqlSessionFactory factory = null; @Before public void prepare() throws IOException&#123; InputStream inputStream = Resources.getResourceAsStream(&quot;mybatis.xml&quot;); factory = new SqlSessionFactoryBuilder().build(inputStream); inputStream.close(); &#125; @Test public void test()&#123; SqlSession session= factory.openSession(); try&#123; StudentMapper studentMapper = session.getMapper(StudentMapper.class); List&lt;Student&gt; list = studentMapper.selectAllStudent(); Iterator&lt;Student&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; Student student = iterator.next(); System.out.println(student); &#125; &#125;finally&#123; session.commit(); session.close(); &#125; &#125; @Test public void testInsert()&#123; SqlSession sqlSession = factory.openSession(); try&#123; StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); Student student = new Student(&quot;young&quot;,20); int affectedRows = studentMapper.insertStudent(student); if(affectedRows==1)&#123; System.out.println(&quot;插入成功!&quot;); System.out.println(student);//查看从数据库返回id填充student的id属性 &#125;else&#123; System.out.println(&quot;插入失败!&quot;); &#125; &#125;finally &#123; sqlSession.commit(); sqlSession.close(); &#125; &#125; @Test public void testUpdate()&#123; SqlSession sqlSession = factory.openSession(); try&#123; StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); Student student = new Student(10000,&quot;Tom&quot;,21); int affectedRows = studentMapper.updateStudent(student); if(affectedRows != 0)&#123; System.out.println(&quot;更新成功!&quot;); System.out.println(student); &#125;else&#123; System.out.println(&quot;更新失败&quot;); &#125; &#125;finally &#123; sqlSession.commit(); sqlSession.close(); &#125; &#125; @Test public void testDelete()&#123; SqlSession sqlSession = factory.openSession(); try&#123; StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); int id = 10000; int affectedRows = studentMapper.deleteById(id); if(affectedRows == 1)&#123; System.out.println(&quot;删除成功!&quot;); &#125;else&#123; System.out.println(&quot;删除失败!&quot;); &#125; &#125;finally &#123; sqlSession.commit(); sqlSession.close(); &#125; &#125;&#125; 注意 插入、删除、修改要获取数据库中受影响的记录数，以便验证操作是否成功 插入一条数据最好返回从数据库返回生成的ID来给model的id赋值，以便后续使用 ```]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1--搭建环境]]></title>
    <url>%2F2019%2F08%2F31%2FMybaits%2F1---%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[####一.单独使用Mybaitsjar包测试:junit数据库驱动: mysql-connector-javaMybatis: mybatislog4j: log4j-core log4j-api1.创建db,properties 1234database.driver=com.mysql.jdbc.Driverdatabase.url=jdbc:mysql://localhost:3306/dbName?serverTimezone=UTC database.username=rootdatabase.password=*** 2.配置mybatis.xml 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--要注意该文件的节点顺序，否则会报错--&gt; &lt;!--引入属性文件--&gt; &lt;properties resource=&quot;db.properties&quot;/&gt; &lt;settings&gt; &lt;!--配置日志,固定写法--&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J2&quot;&gt;&lt;/setting&gt; &lt;/settings&gt; &lt;!--给实体取别名--&gt; &lt;typeAliases&gt; &lt;package name=&quot;dao&quot;/&gt; &lt;package name=&quot;model&quot;/&gt; &lt;/typeAliases&gt; &lt;!--数据源配置--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;database.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;database.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;database.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;database.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入mapple文件--&gt; &lt;mappers &gt; &lt;mapper resource=&quot;mapple/studentMapple.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 3.日志 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt; &lt;Appenders&gt; &lt;Console name=&quot;console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt; &lt;/Console&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt; &lt;logger name=&quot;org.springframework&quot; level=&quot;INFO&quot;&gt;&lt;/logger&gt; &lt;logger name=&quot;org.mybatis&quot; level=&quot;INFO&quot;&gt;&lt;/logger&gt; &lt;root level=&quot;debug&quot;&gt; &lt;appender-ref ref=&quot;console&quot;/&gt; &lt;/root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 4.dao和model 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package dao;import model.Student;import java.util.List;public interface StudentMapper &#123; List&lt;Student&gt; selectAllStudent();&#125;package model;public class Student &#123; private int id; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; + &quot;, age=&quot; + age + &apos;&#125;&apos;; &#125;&#125; 5.mapple 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;dao.StudentMapper&quot;&gt; &lt;select id=&quot;selectAllStudent&quot; resultType=&quot;student&quot;&gt; select * from `student` &lt;/select&gt;&lt;/mapper&gt; 6.测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344import dao.StudentMapper;import model.Student;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Iterator;import java.util.List;public class AppTest &#123; SqlSessionFactory factory = null; @Before public void prepare() throws IOException&#123; InputStream inputStream = Resources.getResourceAsStream(&quot;mybatis.xml&quot;); factory = new SqlSessionFactoryBuilder().build(inputStream); inputStream.close(); &#125; @Test public void test()&#123; SqlSession session= factory.openSession(); try&#123; StudentMapper studentMapper = session.getMapper(StudentMapper.class); List&lt;Student&gt; list = studentMapper.selectAllStudent(); Iterator&lt;Student&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; Student student = iterator.next(); System.out.println(student); &#125; &#125;finally&#123; session.commit(); session.close(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
</search>
